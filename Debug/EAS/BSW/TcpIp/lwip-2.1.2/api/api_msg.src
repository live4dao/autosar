	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 18041957 SN 09003395"
	.compiler_invocation	"ctc -f cc30316a --dep-file=EAS\\BSW\\TcpIp\\lwip-2.1.2\\api\\.api_msg.o.d -c99 --fp-model=3cflnrSTz -D__CPU__=tc39x -D__CPU_TC39X__ --core=tc1.6.2 --fp-model=+float -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\EB_Cfg -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\EB_Cfg\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\EB_Cfg\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Autosar_Srv -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Autosar_Srv\\AS440 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Cfg_Ssw -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Cfg_Ssw\\TC39B -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Integration -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Platform -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Platform\\AS440 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Sfr -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Sfr\\TC39xB -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Sfr\\TC39xB\\_Reg -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Ssw -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Ssw\\TC39B -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Ssw\\TC39B\\Tricore -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc\\inc\\AS440 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Lib -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\App_Func -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\demo -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Adc_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Gtm_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\AscLin_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Can_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\EthV2_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Stm_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Main -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\APP -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\BswM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanNm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanSm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanTp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanTSyn -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Com -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\ComM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Common -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Crc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Dcm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Dem -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Det -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\DoIP -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EcuM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Eth -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthSM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthTrcv -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthTSyn -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\FiM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\FlsTst -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\MemIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Nm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\NvM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\OS -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\OS\\Kernel -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\OS\\Portable -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\PduR -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\RamTst -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\SoAd -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\StbM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\api -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\arch -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv4 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix\\arpa -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix\\net -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix\\sys -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\stdc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip\\apps -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip\\priv -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip\\prot -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\netif -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\netif\\ppp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\netif\\ppp\\polarssl -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\netif -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\netif\\ppp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\netif\\ppp\\polarssl -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\UdpNm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\WdgIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\WdgM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Cal -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Daq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Pag -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Pgm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Std -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\XcpOnEth -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Callout -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Config -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Library\\Vfx_ComE2E -g2 --make-target=EAS\\BSW\\TcpIp\\lwip-2.1.2\\api\\api_msg.o -t2 --language=-gcc,-volatile,+strings,-kanji --default-near-size=0 -O1 --default-a1-size=0 --default-a0-size=0 --source --align=0 --switch=auto --error-limit=42 -o EAS\\BSW\\TcpIp\\lwip-2.1.2\\api\\api_msg.src ..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\api\\api_msg.c"
	.compiler_name		"ctc"
	;source	'..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\api\\api_msg.c'

	
$TC162
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	4544
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\api\\api_msg.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Debug\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	165
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	167
	.byte	5
	.byte	'unsigned char',0,1,8,4
	.byte	'boolean',0,2,102,29
	.word	190
	.byte	4
	.byte	'uint8',0,2,106,29
	.word	190
	.byte	5
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,2,110,29
	.word	237
	.byte	5
	.byte	'unsigned long int',0,4,7,4
	.byte	'uint32',0,2,114,29
	.word	274
	.byte	4
	.byte	'Std_ReturnType',0,3,109,16
	.word	190
	.byte	4
	.byte	'PduIdType',0,4,37,21
	.word	190
	.byte	4
	.byte	'PduLengthType',0,4,41,22
	.word	237
	.byte	6,5,101,9,1,7
	.byte	'BUFREQ_OK',0,0,7
	.byte	'BUFREQ_E_NOT_OK',0,1,7
	.byte	'BUFREQ_E_BUSY',0,2,7
	.byte	'BUFREQ_E_OVFL',0,3,0,4
	.byte	'BufReq_ReturnType',0,5,107,3
	.word	373
	.byte	3
	.word	190
	.byte	4
	.byte	'SduDataPtrType',0,5,189,1,40
	.word	467
	.byte	6,5,204,1,9,1,7
	.byte	'TP_DATACONF',0,0,7
	.byte	'TP_DATARETRY',0,1,7
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,5,216,1,3
	.word	496
	.byte	4
	.byte	'TcpIp_SocketIdType',0,6,50,16
	.word	190
	.byte	8,4
	.word	274
	.byte	9,0,0,10,6,52,9,4,11
	.byte	'Addr',0
	.word	601
	.byte	4,2,35,0,0,4
	.byte	'TcpIp_IpAddressType',0,6,55,3
	.word	610
	.byte	4
	.byte	'TcpIp_DomainType',0,6,61,16
	.word	237
	.byte	10,6,68,9,8,11
	.byte	'Domain',0
	.word	237
	.byte	2,2,35,0,11
	.byte	'Port',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'Addr',0
	.word	601
	.byte	4,2,35,4,0,4
	.byte	'TcpIp_SockAddrInetType',0,6,73,3
	.word	683
	.byte	4
	.byte	'TcpIp_AddressType',0,7,128,1,15
	.word	190
	.byte	4
	.byte	'TcpIp_CtrlIdType',0,7,142,1,15
	.word	190
	.byte	4
	.byte	'TcpIp_IpAddrStateType',0,7,144,1,15
	.word	190
	.byte	4
	.byte	'TcpIp_LocalAddrAssignmentConfigType',0,7,149,1,15
	.word	190
	.byte	4
	.byte	'TcpIp_StaticAddrIdType',0,7,151,1,15
	.word	190
	.byte	10,7,152,1,9,12,11
	.byte	'State',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'Netmask',0
	.word	190
	.byte	1,2,35,1,11
	.byte	'Domain',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'IpAddr',0
	.word	610
	.byte	4,2,35,4,11
	.byte	'DefaultRouter',0
	.word	610
	.byte	4,2,35,8,0,4
	.byte	'TcpIp_StaticIpAddrType',0,7,162,1,3
	.word	925
	.byte	4
	.byte	'TcpIp_LocalAddrIdType',0,7,173,1,15
	.word	190
	.byte	8,3
	.word	190
	.byte	9,2,0,10,7,231,1,9,8,11
	.byte	'CtrlId',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'Address',0
	.word	190
	.byte	1,2,35,1,11
	.byte	'Domain',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'StaticAddrId',0
	.word	190
	.byte	1,2,35,4,11
	.byte	'Assignments',0
	.word	1082
	.byte	3,2,35,5,0,4
	.byte	'TcpIp_LocalAddrConfigType',0,7,243,1,3
	.word	1091
	.byte	10,7,245,1,9,4,11
	.byte	'ArpConfigId',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'DHCPConfigId',0
	.word	190
	.byte	1,2,35,1,11
	.byte	'AutoIpInitTimeout',0
	.word	237
	.byte	2,2,35,2,0,4
	.byte	'TcpIp_IpV4CtrlConfigType',0,7,130,2,3
	.word	1225
	.byte	10,7,133,2,9,8,11
	.byte	'CtrlIdx',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'FramePrio',0
	.word	190
	.byte	1,2,35,1,11
	.byte	'UnicastAddrId',0
	.word	190
	.byte	1,2,35,2,11
	.byte	'UnicastAddrLimit',0
	.word	190
	.byte	1,2,35,3,11
	.byte	'MulticastAddrId',0
	.word	190
	.byte	1,2,35,4,11
	.byte	'LocalAddrLimit',0
	.word	190
	.byte	1,2,35,5,11
	.byte	'IpV4CtrlId',0
	.word	190
	.byte	1,2,35,6,11
	.byte	'IpV6CtrlId',0
	.word	190
	.byte	1,2,35,7,0,4
	.byte	'TcpIp_NetIfCtrlConfigType',0,7,148,2,3
	.word	1336
	.byte	4
	.byte	'SoAd_RoutingGroupIdType',0,8,43,15
	.word	190
	.byte	4
	.byte	'SoAd_SoConIdType',0,8,44,15
	.word	190
	.byte	4
	.byte	'SoAd_SoConGroupIdType',0,8,45,15
	.word	190
	.byte	4
	.byte	'SoAd_PduRouteIdType',0,8,46,15
	.word	190
	.byte	4
	.byte	'SoAd_PduRouteDestIdType',0,8,47,15
	.word	190
	.byte	4
	.byte	'SoAd_SocketRouteIdType',0,8,48,15
	.word	190
	.byte	4
	.byte	'SoAd_IfTxUnconfirmedType',0,8,49,16
	.word	237
	.byte	4
	.byte	'SoAd_IfTxTimerType',0,8,51,16
	.word	237
	.byte	8,1
	.word	190
	.byte	9,0,0,10,8,53,9,2,11
	.byte	'Mask',0
	.word	1790
	.byte	1,2,35,0,11
	.byte	'RoutingState',0
	.word	1790
	.byte	1,2,35,1,0,4
	.byte	'SoAd_RoutingGroupCtrlType',0,8,57,3
	.word	1799
	.byte	6,8,63,9,1,7
	.byte	'SOAD_UL_DOIP',0,0,7
	.byte	'SOAD_UL_UDPNM',0,1,7
	.byte	'SOAD_UL_PDUR',0,2,7
	.byte	'SOAD_UL_XCP',0,3,7
	.byte	'SOAD_UL_MAX',0,4,0,4
	.byte	'SoAd_ULIndexType',0,8,71,3
	.word	1875
	.byte	4
	.byte	'SoAd_RemoteAddressType',0,9,113,32
	.word	683
	.byte	6,9,115,9,1,7
	.byte	'SOAD_SOCON_UNINIT',0,0,7
	.byte	'SOAD_SOCON_OFFLINE',0,1,7
	.byte	'SOAD_SOCON_RECONN',0,2,7
	.byte	'SOAD_SOCON_ONLINE',0,3,0,4
	.byte	'SoAd_SoConModeType',0,9,121,3
	.word	2011
	.byte	12
	.word	190
	.byte	3
	.word	2125
	.byte	12
	.word	190
	.byte	3
	.word	2135
	.byte	12
	.word	190
	.byte	3
	.word	2145
	.byte	12
	.word	1875
	.byte	3
	.word	2155
	.byte	10,9,129,1,9,36,11
	.byte	'IfBufferLength',0
	.word	237
	.byte	2,2,35,0,11
	.byte	'IfBufferOffset',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'TpBufferLength',0
	.word	237
	.byte	2,2,35,4,11
	.byte	'TpBufferOffset',0
	.word	237
	.byte	2,2,35,6,11
	.byte	'PduRouteNum',0
	.word	190
	.byte	1,2,35,8,11
	.byte	'SocketRouteNum',0
	.word	190
	.byte	1,2,35,9,11
	.byte	'PduRouteDestNum',0
	.word	190
	.byte	1,2,35,10,11
	.byte	'RemoteAddrState',0
	.word	190
	.byte	1,2,35,11,11
	.byte	'RemoteAddr',0
	.word	683
	.byte	8,2,35,12,11
	.byte	'PduRouteDestList',0
	.word	2130
	.byte	4,2,35,20,11
	.byte	'PduRouteList',0
	.word	2140
	.byte	4,2,35,24,11
	.byte	'SocketRouteList',0
	.word	2150
	.byte	4,2,35,28,11
	.byte	'SoConModeChgList',0
	.word	2160
	.byte	4,2,35,32,0,4
	.byte	'SoAd_SocketConnectionType',0,9,146,1,3
	.word	2165
	.byte	10,9,148,1,9,16,11
	.byte	'CtrlFlag',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'KeepAliveProbesMax',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'KeepAliveInterval',0
	.word	274
	.byte	4,2,35,4,11
	.byte	'KeepAliveTime',0
	.word	274
	.byte	4,2,35,8,11
	.byte	'TxQuota',0
	.word	274
	.byte	4,2,35,12,0,4
	.byte	'SoAd_TcpProtocolType',0,9,155,1,3
	.word	2517
	.byte	10,9,157,1,9,12,11
	.byte	'CtrlFlag',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'nPduTxBufferMin',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'TriggerTimeout',0
	.word	237
	.byte	2,2,35,4,11
	.byte	'AliveSupervisionTimeout',0
	.word	274
	.byte	4,2,35,6,0,4
	.byte	'SoAd_UdpProtocolType',0,9,163,1,3
	.word	2667
	.byte	12
	.word	2517
	.byte	3
	.word	2804
	.byte	12
	.word	2667
	.byte	3
	.word	2814
	.byte	10,9,165,1,9,24,11
	.byte	'GroupId',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'CtrlFlag',0
	.word	190
	.byte	1,2,35,1,11
	.byte	'FramePriority',0
	.word	190
	.byte	1,2,35,2,11
	.byte	'SoConNum',0
	.word	190
	.byte	1,2,35,3,11
	.byte	'SoConId',0
	.word	190
	.byte	1,2,35,4,11
	.byte	'IpAddrAssignChgNum',0
	.word	190
	.byte	1,2,35,5,11
	.byte	'LocalAddrId',0
	.word	190
	.byte	1,2,35,6,11
	.byte	'LocalPort',0
	.word	237
	.byte	2,2,35,8,11
	.byte	'IpAddrAssignChgList',0
	.word	2160
	.byte	4,2,35,12,11
	.byte	'TcpProtocolPtr',0
	.word	2809
	.byte	4,2,35,16,11
	.byte	'UdpProtocolPtr',0
	.word	2819
	.byte	4,2,35,20,0,4
	.byte	'SoAd_SocketConnectionGroupType',0,9,178,1,3
	.word	2824
	.byte	12
	.word	190
	.byte	3
	.word	3109
	.byte	10,9,180,1,9,12,11
	.byte	'CtrlFlag',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'PduRouteDestNum',0
	.word	190
	.byte	1,2,35,1,11
	.byte	'SocketRouteDestNum',0
	.word	190
	.byte	1,2,35,2,11
	.byte	'PduRouteDestList',0
	.word	3114
	.byte	4,2,35,4,11
	.byte	'SocketRouteDestList',0
	.word	3114
	.byte	4,2,35,8,0,4
	.byte	'SoAd_RoutingGroupType',0,9,187,1,3
	.word	3119
	.byte	10,9,189,1,9,6,11
	.byte	'ULType',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'ULIndex',0
	.word	1875
	.byte	1,2,35,1,11
	.byte	'CtrlFlag',0
	.word	190
	.byte	1,2,35,2,11
	.byte	'RouteDestNum',0
	.word	190
	.byte	1,2,35,3,11
	.byte	'RouteDestId',0
	.word	190
	.byte	1,2,35,4,11
	.byte	'TxPduId',0
	.word	190
	.byte	1,2,35,5,0,4
	.byte	'SoAd_PduRouteType',0,9,204,1,3
	.word	3283
	.byte	3
	.word	1799
	.byte	10,9,206,1,9,20,11
	.byte	'TxPduHeaderId',0
	.word	274
	.byte	4,2,35,0,11
	.byte	'SoConNum',0
	.word	190
	.byte	1,2,35,4,11
	.byte	'SoConId',0
	.word	190
	.byte	1,2,35,5,11
	.byte	'PduRouteId',0
	.word	190
	.byte	1,2,35,6,11
	.byte	'UdpTriggerMode',0
	.word	190
	.byte	1,2,35,7,11
	.byte	'UdpTriggerTimeout',0
	.word	237
	.byte	2,2,35,8,11
	.byte	'RoutingCtrlList',0
	.word	3428
	.byte	4,2,35,12,11
	.byte	'IfTriggerList',0
	.word	467
	.byte	4,2,35,16,0,4
	.byte	'SoAd_PduRouteDestType',0,9,217,1,3
	.word	3433
	.byte	10,9,219,1,9,16,11
	.byte	'RxPduHeaderId',0
	.word	274
	.byte	4,2,35,0,11
	.byte	'ULType',0
	.word	190
	.byte	1,2,35,4,11
	.byte	'ULIndex',0
	.word	1875
	.byte	1,2,35,5,11
	.byte	'SoConNum',0
	.word	190
	.byte	1,2,35,6,11
	.byte	'SoConId',0
	.word	190
	.byte	1,2,35,7,11
	.byte	'RxPduId',0
	.word	190
	.byte	1,2,35,8,11
	.byte	'RoutingCtrlList',0
	.word	3428
	.byte	4,2,35,12,0,4
	.byte	'SoAd_SocketRouteType',0,9,236,1,3
	.word	3648
	.byte	12
	.word	3433
	.byte	3
	.word	3818
	.byte	10,9,155,2,9,24,11
	.byte	'State',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'Timer',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'BufferLength',0
	.word	237
	.byte	2,2,35,4,11
	.byte	'BufferOffset',0
	.word	237
	.byte	2,2,35,6,11
	.byte	'UdpTxBuffer',0
	.word	467
	.byte	4,2,35,8,11
	.byte	'TotalTxLength',0
	.word	237
	.byte	2,2,35,12,11
	.byte	'UsedTxLength',0
	.word	237
	.byte	2,2,35,14,11
	.byte	'IfTxDataBuffer',0
	.word	3114
	.byte	4,2,35,16,11
	.byte	'PduRouteDestPtr',0
	.word	3823
	.byte	4,2,35,20,0,4
	.byte	'SoAd_TxSessionType',0,9,177,2,3
	.word	3828
	.byte	12
	.word	3648
	.byte	3
	.word	4052
	.byte	10,9,180,2,9,8,11
	.byte	'PduLength',0
	.word	237
	.byte	2,2,35,0,11
	.byte	'RemainLength',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'SocketRoutePtr',0
	.word	4057
	.byte	4,2,35,4,0,4
	.byte	'SoAd_RxPduInfoType',0,9,185,2,3
	.word	4062
	.byte	10,9,187,2,9,12,11
	.byte	'TotalLength',0
	.word	237
	.byte	2,2,35,0,11
	.byte	'In',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'Out',0
	.word	237
	.byte	2,2,35,4,11
	.byte	'BufferPtr',0
	.word	467
	.byte	4,2,35,8,0,4
	.byte	'SoAd_RxFifoType',0,9,193,2,3
	.word	4162
	.byte	10,9,195,2,9,8,11
	.byte	'TotalLength',0
	.word	237
	.byte	2,2,35,0,11
	.byte	'UsedLength',0
	.word	237
	.byte	2,2,35,2,11
	.byte	'BufferPtr',0
	.word	467
	.byte	4,2,35,4,0,4
	.byte	'SoAd_RxBufferType',0,9,200,2,3
	.word	4259
	.byte	8,8
	.word	190
	.byte	9,7,0,10,9,202,2,9,48,11
	.byte	'State',0
	.word	190
	.byte	1,2,35,0,11
	.byte	'ValidHeaderLen',0
	.word	190
	.byte	1,2,35,1,11
	.byte	'PduHeader',0
	.word	4353
	.byte	8,2,35,2,11
	.byte	'RxPduInfo',0
	.word	4062
	.byte	8,2,35,12,11
	.byte	'ProcessPduInfo',0
	.word	4062
	.byte	8,2,35,20,11
	.byte	'IfBuffer',0
	.word	4259
	.byte	8,2,35,28,11
	.byte	'TpBuffer',0
	.word	4162
	.byte	12,2,35,36,0,4
	.byte	'SoAd_RxSessionType',0,9,216,2,3
	.word	4362
	.byte	4
	.byte	'u8_t',0,10,61,25
	.word	190
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,36,0,3,8,11,15,62,15,0,0,6,4,1,58,15,59,15,57,15,11,15,0,0,7,40,0,3,8,28,13,0,0,8,1
	.byte	1,11,15,73,19,0,0,9,33,0,47,15,0,0,10,19,1,58,15,59,15,57,15,11,15,0,0,11,13,0,3,8,73,19,11,15,56,9,0
	.byte	0,12,38,0,73,19,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L7-.L6
.L6:
	.half	3
	.word	.L9-.L8
.L8:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Platform',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Config',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Autosar_Srv',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\SoAd',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\arch',0,0
	.byte	'..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\api\\api_msg.c',0,0,0,0
	.byte	'Platform_Types.h',0,1,0,0
	.byte	'Std_Types.h',0,1,0,0
	.byte	'ComStack_Types_Cfg.h',0,2,0,0
	.byte	'ComStack_Types.h',0,3,0,0
	.byte	'TcpIp_GeneratedTypes.h',0,2,0,0
	.byte	'TcpIp_Types.h',0,4,0,0
	.byte	'SoAd_GeneratedTypes.h',0,2,0,0
	.byte	'SoAd_Types.h',0,5,0,0
	.byte	'cc.h',0,6,0,0,0
.L9:
.L7:

; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     1  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     2   * @file
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     3   * Sequential API Internal module
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     4   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     5   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     6  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     7  /*
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     8   * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	     9   * All rights reserved.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    10   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    11   * Redistribution and use in source and binary forms, with or without modification,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    12   * are permitted provided that the following conditions are met:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    13   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    14   * 1. Redistributions of source code must retain the above copyright notice,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    15   *    this list of conditions and the following disclaimer.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    16   * 2. Redistributions in binary form must reproduce the above copyright notice,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    17   *    this list of conditions and the following disclaimer in the documentation
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    18   *    and/or other materials provided with the distribution.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    19   * 3. The name of the author may not be used to endorse or promote products
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    20   *    derived from this software without specific prior written permission.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    21   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    22   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    23   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    24   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    25   * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    26   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    27   * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    28   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    29   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    30   * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    31   * OF SUCH DAMAGE.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    32   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    33   * This file is part of the lwIP TCP/IP stack.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    34   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    35   * Author: Adam Dunkels <adam@sics.se>
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    36   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    37   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    38  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    39  #include "lwip/opt.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    40  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    41  #if LWIP_NETCONN /* don't build if not configured for use in lwipopts.h */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    42  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    43  #include "lwip/priv/api_msg.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    44  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    45  #include "lwip/ip.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    46  #include "lwip/ip_addr.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    47  #include "lwip/udp.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    48  #include "lwip/tcp.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    49  #include "lwip/raw.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    50  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    51  #include "lwip/memp.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    52  #include "lwip/igmp.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    53  #include "lwip/dns.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    54  #include "lwip/mld6.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    55  #include "lwip/priv/tcpip_priv.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    56  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    57  #include <string.h>
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    58  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    59  /* netconns are polled once per second (e.g. continue write on memory error) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    60  #define NETCONN_TCP_POLL_INTERVAL 2
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    61  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    62  #define SET_NONBLOCKING_CONNECT(conn, val)  do { if (val) { \ 
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    63    netconn_set_flags(conn, NETCONN_FLAG_IN_NONBLOCKING_CONNECT); \ 
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    64  } else { \ 
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    65    netconn_clear_flags(conn, NETCONN_FLAG_IN_NONBLOCKING_CONNECT); }} while(0)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    66  #define IN_NONBLOCKING_CONNECT(conn) netconn_is_flag_set(conn, NETCONN_FLAG_IN_NONBLOCKING_CONNECT)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    67  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    68  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    69  #define NETCONN_MBOX_VALID(conn, mbox) (sys_mbox_valid(mbox) && ((conn->flags & NETCONN_FLAG_MBOXINVALID) == 0))
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    70  #else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    71  #define NETCONN_MBOX_VALID(conn, mbox) sys_mbox_valid(mbox)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    72  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    73  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    74  /* forward declarations */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    75  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    76  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    77  #define WRITE_DELAYED         , 1
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    78  #define WRITE_DELAYED_PARAM   , u8_t delayed
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    79  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    80  #define WRITE_DELAYED
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    81  #define WRITE_DELAYED_PARAM
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    82  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    83  static err_t lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    84  static err_t lwip_netconn_do_close_internal(struct netconn *conn  WRITE_DELAYED_PARAM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    85  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    86  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    87  static void netconn_drain(struct netconn *conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    88  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    89  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    90  #define TCPIP_APIMSG_ACK(m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    91  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    92  #define TCPIP_APIMSG_ACK(m)   do { sys_sem_signal(LWIP_API_MSG_SEM(m)); } while(0)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    93  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    94  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    95  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    96  const u8_t netconn_deleted = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    97  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    98  int
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	    99  lwip_netconn_is_deallocated_msg(void *msg)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   100  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   101    if (msg == &netconn_deleted) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   102      return 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   103    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   104    return 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   105  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   106  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   107  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   108  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   109  const u8_t netconn_aborted = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   110  const u8_t netconn_reset = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   111  const u8_t netconn_closed = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   112  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   113  /** Translate an error to a unique void* passed via an mbox */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   114  static void *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   115  lwip_netconn_err_to_msg(err_t err)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   116  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   117    switch (err) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   118      case ERR_ABRT:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   119        return LWIP_CONST_CAST(void *, &netconn_aborted);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   120      case ERR_RST:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   121        return LWIP_CONST_CAST(void *, &netconn_reset);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   122      case ERR_CLSD:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   123        return LWIP_CONST_CAST(void *, &netconn_closed);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   124      default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   125        LWIP_ASSERT("unhandled error", err == ERR_OK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   126        return NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   127    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   128  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   129  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   130  int
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   131  lwip_netconn_is_err_msg(void *msg, err_t *err)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   132  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   133    LWIP_ASSERT("err != NULL", err != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   134  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   135    if (msg == &netconn_aborted) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   136      *err = ERR_ABRT;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   137      return 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   138    } else if (msg == &netconn_reset) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   139      *err = ERR_RST;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   140      return 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   141    } else if (msg == &netconn_closed) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   142      *err = ERR_CLSD;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   143      return 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   144    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   145    return 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   146  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   147  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   148  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   149  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   150  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   151  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   152   * Receive callback function for RAW netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   153   * Doesn't 'eat' the packet, only copies it and sends it to
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   154   * conn->recvmbox
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   155   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   156   * @see raw.h (struct raw_pcb.recv) for parameters and return value
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   157   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   158  static u8_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   159  recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   160           const ip_addr_t *addr)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   161  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   162    struct pbuf *q;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   163    struct netbuf *buf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   164    struct netconn *conn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   165  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   166    LWIP_UNUSED_ARG(addr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   167    conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   168  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   169    if ((conn != NULL) && NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   170  #if LWIP_SO_RCVBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   171      int recv_avail;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   172      SYS_ARCH_GET(conn->recv_avail, recv_avail);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   173      if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   174        return 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   175      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   176  #endif /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   177      /* copy the whole packet into new pbufs */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   178      q = pbuf_clone(PBUF_RAW, PBUF_RAM, p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   179      if (q != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   180        u16_t len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   181        buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   182        if (buf == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   183          pbuf_free(q);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   184          return 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   185        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   186  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   187        buf->p = q;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   188        buf->ptr = q;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   189        ip_addr_copy(buf->addr, *ip_current_src_addr());
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   190        buf->port = pcb->protocol;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   191  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   192        len = q->tot_len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   193        if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   194          netbuf_delete(buf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   195          return 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   196        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   197  #if LWIP_SO_RCVBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   198          SYS_ARCH_INC(conn->recv_avail, len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   199  #endif /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   200          /* Register event with callback */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   201          API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   202        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   203      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   204    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   205  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   206    return 0; /* do not eat the packet */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   207  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   208  #endif /* LWIP_RAW*/
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   209  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   210  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   211  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   212   * Receive callback function for UDP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   213   * Posts the packet to conn->recvmbox or deletes it on memory error.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   214   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   215   * @see udp.h (struct udp_pcb.recv) for parameters
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   216   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   217  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   218  recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   219           const ip_addr_t *addr, u16_t port)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   220  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   221    struct netbuf *buf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   222    struct netconn *conn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   223    u16_t len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   224  #if LWIP_SO_RCVBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   225    int recv_avail;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   226  #endif /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   227  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   228    LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   229    LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   230    LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   231    conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   232  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   233    if (conn == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   234      pbuf_free(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   235      return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   236    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   237  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   238    LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   239  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   240  #if LWIP_SO_RCVBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   241    SYS_ARCH_GET(conn->recv_avail, recv_avail);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   242    if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   243        ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   244  #else  /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   245    if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   246  #endif /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   247      pbuf_free(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   248      return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   249    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   250  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   251    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   252    if (buf == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   253      pbuf_free(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   254      return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   255    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   256      buf->p = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   257      buf->ptr = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   258      ip_addr_set(&buf->addr, addr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   259      buf->port = port;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   260  #if LWIP_NETBUF_RECVINFO
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   261      if (conn->flags & NETCONN_FLAG_PKTINFO) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   262        /* get the UDP header - always in the first pbuf, ensured by udp_input */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   263        const struct udp_hdr *udphdr = (const struct udp_hdr *)ip_next_header_ptr();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   264        buf->flags = NETBUF_FLAG_DESTADDR;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   265        ip_addr_set(&buf->toaddr, ip_current_dest_addr());
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   266        buf->toport_chksum = udphdr->dest;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   267      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   268  #endif /* LWIP_NETBUF_RECVINFO */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   269    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   270  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   271    len = p->tot_len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   272    if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   273      netbuf_delete(buf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   274      return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   275    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   276  #if LWIP_SO_RCVBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   277      SYS_ARCH_INC(conn->recv_avail, len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   278  #endif /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   279      /* Register event with callback */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   280      API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   281    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   282  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   283  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   284  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   285  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   286  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   287   * Receive callback function for TCP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   288   * Posts the packet to conn->recvmbox, but doesn't delete it on errors.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   289   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   290   * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   291   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   292  static err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   293  recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   294  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   295    struct netconn *conn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   296    u16_t len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   297    void *msg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   298  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   299    LWIP_UNUSED_ARG(pcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   300    LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   301    LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   302    LWIP_ASSERT("err != ERR_OK unhandled", err == ERR_OK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   303    LWIP_UNUSED_ARG(err); /* for LWIP_NOASSERT */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   304    conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   305  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   306    if (conn == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   307      return ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   308    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   309    LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   310  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   311    if (!NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   312      /* recvmbox already deleted */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   313      if (p != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   314        tcp_recved(pcb, p->tot_len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   315        pbuf_free(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   316      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   317      return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   318    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   319    /* Unlike for UDP or RAW pcbs, don't check for available space
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   320       using recv_avail since that could break the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   321       (data is already ACKed) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   322  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   323    if (p != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   324      msg = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   325      len = p->tot_len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   326    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   327      msg = LWIP_CONST_CAST(void *, &netconn_closed);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   328      len = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   329    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   330  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   331    if (sys_mbox_trypost(&conn->recvmbox, msg) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   332      /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   333      return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   334    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   335  #if LWIP_SO_RCVBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   336      SYS_ARCH_INC(conn->recv_avail, len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   337  #endif /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   338      /* Register event with callback */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   339      API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   340    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   341  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   342    return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   343  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   344  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   345  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   346   * Poll callback function for TCP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   347   * Wakes up an application thread that waits for a connection to close
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   348   * or data to be sent. The application thread then takes the
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   349   * appropriate action to go on.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   350   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   351   * Signals the conn->sem.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   352   * netconn_close waits for conn->sem if closing failed.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   353   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   354   * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   355   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   356  static err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   357  poll_tcp(void *arg, struct tcp_pcb *pcb)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   358  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   359    struct netconn *conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   360  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   361    LWIP_UNUSED_ARG(pcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   362    LWIP_ASSERT("conn != NULL", (conn != NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   363  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   364    if (conn->state == NETCONN_WRITE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   365      lwip_netconn_do_writemore(conn  WRITE_DELAYED);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   366    } else if (conn->state == NETCONN_CLOSE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   367  #if !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   368      if (conn->current_msg && conn->current_msg->msg.sd.polls_left) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   369        conn->current_msg->msg.sd.polls_left--;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   370      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   371  #endif /* !LWIP_SO_SNDTIMEO && !LWIP_SO_LINGER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   372      lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   373    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   374    /* @todo: implement connect timeout here? */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   375  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   376    /* Did a nonblocking write fail before? Then check available write-space. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   377    if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   378      /* If the queued byte- or pbuf-count drops below the configured low-water limit,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   379         let select mark this pcb as writable again. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   380      if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   381          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   382        netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   383        API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   384      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   385    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   386  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   387    return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   388  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   389  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   390  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   391   * Sent callback function for TCP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   392   * Signals the conn->sem and calls API_EVENT.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   393   * netconn_write waits for conn->sem if send buffer is low.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   394   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   395   * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   396   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   397  static err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   398  sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   399  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   400    struct netconn *conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   401  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   402    LWIP_UNUSED_ARG(pcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   403    LWIP_ASSERT("conn != NULL", (conn != NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   404  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   405    if (conn) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   406      if (conn->state == NETCONN_WRITE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   407        lwip_netconn_do_writemore(conn  WRITE_DELAYED);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   408      } else if (conn->state == NETCONN_CLOSE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   409        lwip_netconn_do_close_internal(conn  WRITE_DELAYED);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   410      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   411  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   412      /* If the queued byte- or pbuf-count drops below the configured low-water limit,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   413         let select mark this pcb as writable again. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   414      if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   415          (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   416        netconn_clear_flags(conn, NETCONN_FLAG_CHECK_WRITESPACE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   417        API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   418      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   419    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   420  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   421    return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   422  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   423  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   424  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   425   * Error callback function for TCP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   426   * Signals conn->sem, posts to all conn mboxes and calls API_EVENT.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   427   * The application thread has then to decide what to do.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   428   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   429   * @see tcp.h (struct tcp_pcb.err) for parameters
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   430   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   431  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   432  err_tcp(void *arg, err_t err)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   433  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   434    struct netconn *conn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   435    enum netconn_state old_state;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   436    void *mbox_msg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   437    SYS_ARCH_DECL_PROTECT(lev);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   438  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   439    conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   440    LWIP_ASSERT("conn != NULL", (conn != NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   441  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   442    SYS_ARCH_PROTECT(lev);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   443  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   444    /* when err is called, the pcb is deallocated, so delete the reference */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   445    conn->pcb.tcp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   446    /* store pending error */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   447    conn->pending_err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   448    /* prevent application threads from blocking on 'recvmbox'/'acceptmbox' */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   449    conn->flags |= NETCONN_FLAG_MBOXCLOSED;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   450  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   451    /* reset conn->state now before waking up other threads */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   452    old_state = conn->state;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   453    conn->state = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   454  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   455    SYS_ARCH_UNPROTECT(lev);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   456  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   457    /* Notify the user layer about a connection error. Used to signal select. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   458    API_EVENT(conn, NETCONN_EVT_ERROR, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   459    /* Try to release selects pending on 'read' or 'write', too.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   460       They will get an error if they actually try to read or write. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   461    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   462    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   463  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   464    mbox_msg = lwip_netconn_err_to_msg(err);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   465    /* pass error message to recvmbox to wake up pending recv */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   466    if (NETCONN_MBOX_VALID(conn, &conn->recvmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   467      /* use trypost to prevent deadlock */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   468      sys_mbox_trypost(&conn->recvmbox, mbox_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   469    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   470    /* pass error message to acceptmbox to wake up pending accept */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   471    if (NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   472      /* use trypost to preven deadlock */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   473      sys_mbox_trypost(&conn->acceptmbox, mbox_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   474    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   475  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   476    if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   477        (old_state == NETCONN_CONNECT)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   478      /* calling lwip_netconn_do_writemore/lwip_netconn_do_close_internal is not necessary
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   479         since the pcb has already been deleted! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   480      int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   481      SET_NONBLOCKING_CONNECT(conn, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   482  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   483      if (!was_nonblocking_connect) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   484        sys_sem_t *op_completed_sem;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   485        /* set error return code */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   486        LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   487        if (old_state == NETCONN_CLOSE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   488          /* let close succeed: the connection is closed after all... */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   489          conn->current_msg->err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   490        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   491          /* Write and connect fail */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   492          conn->current_msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   493        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   494        op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   495        LWIP_ASSERT("inavlid op_completed_sem", sys_sem_valid(op_completed_sem));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   496        conn->current_msg = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   497        /* wake up the waiting task */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   498        sys_sem_signal(op_completed_sem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   499      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   500        /* @todo: test what happens for error on nonblocking connect */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   501      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   502    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   503      LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   504    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   505  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   506  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   507  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   508   * Setup a tcp_pcb with the correct callback function pointers
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   509   * and their arguments.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   510   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   511   * @param conn the TCP netconn to setup
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   512   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   513  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   514  setup_tcp(struct netconn *conn)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   515  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   516    struct tcp_pcb *pcb;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   517  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   518    pcb = conn->pcb.tcp;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   519    tcp_arg(pcb, conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   520    tcp_recv(pcb, recv_tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   521    tcp_sent(pcb, sent_tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   522    tcp_poll(pcb, poll_tcp, NETCONN_TCP_POLL_INTERVAL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   523    tcp_err(pcb, err_tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   524  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   525  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   526  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   527   * Accept callback function for TCP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   528   * Allocates a new netconn and posts that to conn->acceptmbox.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   529   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   530   * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   531   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   532  static err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   533  accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   534  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   535    struct netconn *newconn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   536    struct netconn *conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   537  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   538    if (conn == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   539      return ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   540    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   541    if (!NETCONN_MBOX_VALID(conn, &conn->acceptmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   542      LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   543      return ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   544    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   545  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   546    if (newpcb == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   547      /* out-of-pcbs during connect: pass on this error to the application */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   548      if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   549        /* Register event with callback */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   550        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   551      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   552      return ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   553    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   554    LWIP_ASSERT("expect newpcb == NULL or err == ERR_OK", err == ERR_OK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   555    LWIP_UNUSED_ARG(err); /* for LWIP_NOASSERT */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   556  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   557    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->state: %s\n", tcp_debug_state_str(newpcb->state)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   558  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   559    /* We have to set the callback here even though
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   560     * the new socket is unknown. newconn->socket is marked as -1. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   561    newconn = netconn_alloc(conn->type, conn->callback);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   562    if (newconn == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   563      /* outof netconns: pass on this error to the application */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   564      if (sys_mbox_trypost(&conn->acceptmbox, lwip_netconn_err_to_msg(ERR_ABRT)) == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   565        /* Register event with callback */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   566        API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   567      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   568      return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   569    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   570    newconn->pcb.tcp = newpcb;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   571    setup_tcp(newconn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   572  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   573    /* handle backlog counter */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   574    tcp_backlog_delayed(newpcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   575  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   576    if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   577      /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   578         so do nothing here! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   579      /* remove all references to this netconn from the pcb */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   580      struct tcp_pcb *pcb = newconn->pcb.tcp;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   581      tcp_arg(pcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   582      tcp_recv(pcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   583      tcp_sent(pcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   584      tcp_poll(pcb, NULL, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   585      tcp_err(pcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   586      /* remove reference from to the pcb from this netconn */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   587      newconn->pcb.tcp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   588      /* no need to drain since we know the recvmbox is empty. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   589      sys_mbox_free(&newconn->recvmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   590      sys_mbox_set_invalid(&newconn->recvmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   591      netconn_free(newconn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   592      return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   593    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   594      /* Register event with callback */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   595      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   596    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   597  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   598    return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   599  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   600  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   601  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   602  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   603   * Create a new pcb of a specific type.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   604   * Called from lwip_netconn_do_newconn().
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   605   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   606   * @param msg the api_msg describing the connection type
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   607   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   608  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   609  pcb_new(struct api_msg *msg)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   610  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   611    enum lwip_ip_addr_type iptype = IPADDR_TYPE_V4;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   612  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   613    LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   614  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   615  #if LWIP_IPV6 && LWIP_IPV4
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   616    /* IPv6: Dual-stack by default, unless netconn_set_ipv6only() is called */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   617    if (NETCONNTYPE_ISIPV6(netconn_type(msg->conn))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   618      iptype = IPADDR_TYPE_ANY;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   619    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   620  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   621  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   622    /* Allocate a PCB for this connection */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   623    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   624  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   625      case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   626        msg->conn->pcb.raw = raw_new_ip_type(iptype, msg->msg.n.proto);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   627        if (msg->conn->pcb.raw != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   628  #if LWIP_IPV6
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   629          /* ICMPv6 packets should always have checksum calculated by the stack as per RFC 3542 chapter 3.1 */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   630          if (NETCONNTYPE_ISIPV6(msg->conn->type) && msg->conn->pcb.raw->protocol == IP6_NEXTH_ICMP6) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   631            msg->conn->pcb.raw->chksum_reqd = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   632            msg->conn->pcb.raw->chksum_offset = 2;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   633          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   634  #endif /* LWIP_IPV6 */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   635          raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   636        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   637        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   638  #endif /* LWIP_RAW */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   639  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   640      case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   641        msg->conn->pcb.udp = udp_new_ip_type(iptype);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   642        if (msg->conn->pcb.udp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   643  #if LWIP_UDPLITE
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   644          if (NETCONNTYPE_ISUDPLITE(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   645            udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   646          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   647  #endif /* LWIP_UDPLITE */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   648          if (NETCONNTYPE_ISUDPNOCHKSUM(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   649            udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   650          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   651          udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   652        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   653        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   654  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   655  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   656      case NETCONN_TCP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   657        msg->conn->pcb.tcp = tcp_new_ip_type(iptype);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   658        if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   659          setup_tcp(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   660        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   661        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   662  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   663      default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   664        /* Unsupported netconn type, e.g. protocol disabled */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   665        msg->err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   666        return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   667    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   668    if (msg->conn->pcb.ip == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   669      msg->err = ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   670    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   671  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   672  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   673  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   674   * Create a new pcb of a specific type inside a netconn.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   675   * Called from netconn_new_with_proto_and_callback.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   676   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   677   * @param m the api_msg describing the connection type
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   678   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   679  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   680  lwip_netconn_do_newconn(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   681  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   682    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   683  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   684    msg->err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   685    if (msg->conn->pcb.tcp == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   686      pcb_new(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   687    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   688    /* Else? This "new" connection already has a PCB allocated. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   689    /* Is this an error condition? Should it be deleted? */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   690    /* We currently just are happy and return. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   691  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   692    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   693  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   694  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   695  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   696   * Create a new netconn (of a specific type) that has a callback function.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   697   * The corresponding pcb is NOT created!
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   698   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   699   * @param t the type of 'connection' to create (@see enum netconn_type)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   700   * @param callback a function to call on status changes (RX available, TX'ed)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   701   * @return a newly allocated struct netconn or
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   702   *         NULL on memory error
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   703   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   704  struct netconn *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   705  netconn_alloc(enum netconn_type t, netconn_callback callback)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   706  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   707    struct netconn *conn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   708    int size;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   709    u8_t init_flags = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   710  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   711    conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   712    if (conn == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   713      return NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   714    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   715  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   716    conn->pending_err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   717    conn->type = t;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   718    conn->pcb.tcp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   719  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   720    /* If all sizes are the same, every compiler should optimize this switch to nothing */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   721    switch (NETCONNTYPE_GROUP(t)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   722  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   723      case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   724        size = DEFAULT_RAW_RECVMBOX_SIZE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   725        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   726  #endif /* LWIP_RAW */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   727  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   728      case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   729        size = DEFAULT_UDP_RECVMBOX_SIZE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   730  #if LWIP_NETBUF_RECVINFO
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   731        init_flags |= NETCONN_FLAG_PKTINFO;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   732  #endif /* LWIP_NETBUF_RECVINFO */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   733        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   734  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   735  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   736      case NETCONN_TCP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   737        size = DEFAULT_TCP_RECVMBOX_SIZE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   738        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   739  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   740      default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   741        LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   742        goto free_and_return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   743    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   744  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   745    if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   746      goto free_and_return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   747    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   748  #if !LWIP_NETCONN_SEM_PER_THREAD
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   749    if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   750      sys_mbox_free(&conn->recvmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   751      goto free_and_return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   752    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   753  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   754  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   755  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   756    sys_mbox_set_invalid(&conn->acceptmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   757  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   758    conn->state        = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   759  #if LWIP_SOCKET
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   760    /* initialize socket to -1 since 0 is a valid socket */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   761    conn->socket       = -1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   762  #endif /* LWIP_SOCKET */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   763    conn->callback     = callback;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   764  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   765    conn->current_msg  = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   766  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   767  #if LWIP_SO_SNDTIMEO
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   768    conn->send_timeout = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   769  #endif /* LWIP_SO_SNDTIMEO */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   770  #if LWIP_SO_RCVTIMEO
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   771    conn->recv_timeout = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   772  #endif /* LWIP_SO_RCVTIMEO */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   773  #if LWIP_SO_RCVBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   774    conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   775    conn->recv_avail   = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   776  #endif /* LWIP_SO_RCVBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   777  #if LWIP_SO_LINGER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   778    conn->linger = -1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   779  #endif /* LWIP_SO_LINGER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   780    conn->flags = init_flags;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   781    return conn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   782  free_and_return:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   783    memp_free(MEMP_NETCONN, conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   784    return NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   785  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   786  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   787  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   788   * Delete a netconn and all its resources.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   789   * The pcb is NOT freed (since we might not be in the right thread context do this).
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   790   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   791   * @param conn the netconn to free
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   792   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   793  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   794  netconn_free(struct netconn *conn)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   795  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   796    LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   797  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   798  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   799    /* in fullduplex, netconn is drained here */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   800    netconn_drain(conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   801  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   802  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   803    LWIP_ASSERT("recvmbox must be deallocated before calling this function",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   804                !sys_mbox_valid(&conn->recvmbox));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   805  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   806    LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   807                !sys_mbox_valid(&conn->acceptmbox));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   808  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   809  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   810  #if !LWIP_NETCONN_SEM_PER_THREAD
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   811    sys_sem_free(&conn->op_completed);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   812    sys_sem_set_invalid(&conn->op_completed);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   813  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   814  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   815    memp_free(MEMP_NETCONN, conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   816  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   817  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   818  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   819   * Delete rcvmbox and acceptmbox of a netconn and free the left-over data in
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   820   * these mboxes
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   821   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   822   * @param conn the netconn to free
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   823   * @bytes_drained bytes drained from recvmbox
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   824   * @accepts_drained pending connections drained from acceptmbox
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   825   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   826  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   827  netconn_drain(struct netconn *conn)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   828  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   829    void *mem;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   830  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   831    /* This runs when mbox and netconn are marked as closed,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   832       so we don't need to lock against rx packets */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   833  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   834    LWIP_ASSERT("netconn marked closed", conn->flags & NETCONN_FLAG_MBOXINVALID);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   835  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   836  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   837    /* Delete and drain the recvmbox. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   838    if (sys_mbox_valid(&conn->recvmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   839      while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   840  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   841        if (!lwip_netconn_is_deallocated_msg(mem))
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   842  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   843        {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   844  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   845          if (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   846            err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   847            if (!lwip_netconn_is_err_msg(mem, &err)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   848              pbuf_free((struct pbuf *)mem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   849            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   850          } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   851  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   852          {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   853            netbuf_delete((struct netbuf *)mem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   854          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   855        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   856      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   857      sys_mbox_free(&conn->recvmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   858      sys_mbox_set_invalid(&conn->recvmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   859    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   860  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   861    /* Delete and drain the acceptmbox. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   862  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   863    if (sys_mbox_valid(&conn->acceptmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   864      while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   865  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   866        if (!lwip_netconn_is_deallocated_msg(mem))
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   867  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   868        {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   869          err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   870          if (!lwip_netconn_is_err_msg(mem, &err)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   871            struct netconn *newconn = (struct netconn *)mem;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   872            /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   873            /* pcb might be set to NULL already by err_tcp() */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   874            /* drain recvmbox */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   875            netconn_drain(newconn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   876            if (newconn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   877              tcp_abort(newconn->pcb.tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   878              newconn->pcb.tcp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   879            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   880            netconn_free(newconn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   881          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   882        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   883      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   884      sys_mbox_free(&conn->acceptmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   885      sys_mbox_set_invalid(&conn->acceptmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   886    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   887  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   888  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   889  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   890  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   891  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   892  netconn_mark_mbox_invalid(struct netconn *conn)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   893  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   894    int i, num_waiting;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   895    void *msg = LWIP_CONST_CAST(void *, &netconn_deleted);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   896  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   897    /* Prevent new calls/threads from reading from the mbox */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   898    conn->flags |= NETCONN_FLAG_MBOXINVALID;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   899  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   900    SYS_ARCH_LOCKED(num_waiting = conn->mbox_threads_waiting);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   901    for (i = 0; i < num_waiting; i++) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   902      if (sys_mbox_valid_val(conn->recvmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   903        sys_mbox_trypost(&conn->recvmbox, msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   904      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   905        sys_mbox_trypost(&conn->acceptmbox, msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   906      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   907    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   908  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   909  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   910  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   911  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   912  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   913   * Internal helper function to close a TCP netconn: since this sometimes
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   914   * doesn't work at the first attempt, this function is called from multiple
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   915   * places.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   916   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   917   * @param conn the TCP netconn to close
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   918   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   919  static err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   920  lwip_netconn_do_close_internal(struct netconn *conn  WRITE_DELAYED_PARAM)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   921  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   922    err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   923    u8_t shut, shut_rx, shut_tx, shut_close;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   924    u8_t close_finished = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   925    struct tcp_pcb *tpcb;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   926  #if LWIP_SO_LINGER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   927    u8_t linger_wait_required = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   928  #endif /* LWIP_SO_LINGER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   929  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   930    LWIP_ASSERT("invalid conn", (conn != NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   931    LWIP_ASSERT("this is for tcp netconns only", (NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   932    LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   933    LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   934    LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   935  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   936    tpcb = conn->pcb.tcp;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   937    shut = conn->current_msg->msg.sd.shut;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   938    shut_rx = shut & NETCONN_SHUT_RD;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   939    shut_tx = shut & NETCONN_SHUT_WR;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   940    /* shutting down both ends is the same as closing
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   941       (also if RD or WR side was shut down before already) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   942    if (shut == NETCONN_SHUT_RDWR) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   943      shut_close = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   944    } else if (shut_rx &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   945               ((tpcb->state == FIN_WAIT_1) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   946                (tpcb->state == FIN_WAIT_2) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   947                (tpcb->state == CLOSING))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   948      shut_close = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   949    } else if (shut_tx && ((tpcb->flags & TF_RXCLOSED) != 0)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   950      shut_close = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   951    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   952      shut_close = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   953    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   954  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   955    /* Set back some callback pointers */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   956    if (shut_close) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   957      tcp_arg(tpcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   958    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   959    if (tpcb->state == LISTEN) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   960      tcp_accept(tpcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   961    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   962      /* some callbacks have to be reset if tcp_close is not successful */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   963      if (shut_rx) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   964        tcp_recv(tpcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   965        tcp_accept(tpcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   966      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   967      if (shut_tx) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   968        tcp_sent(tpcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   969      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   970      if (shut_close) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   971        tcp_poll(tpcb, NULL, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   972        tcp_err(tpcb, NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   973      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   974    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   975    /* Try to close the connection */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   976    if (shut_close) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   977  #if LWIP_SO_LINGER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   978      /* check linger possibilites before calling tcp_close */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   979      err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   980      /* linger enabled/required at all? (i.e. is there untransmitted data left?) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   981      if ((conn->linger >= 0) && (conn->pcb.tcp->unsent || conn->pcb.tcp->unacked)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   982        if ((conn->linger == 0)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   983          /* data left but linger prevents waiting */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   984          tcp_abort(tpcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   985          tpcb = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   986        } else if (conn->linger > 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   987          /* data left and linger says we should wait */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   988          if (netconn_is_nonblocking(conn)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   989            /* data left on a nonblocking netconn -> cannot linger */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   990            err = ERR_WOULDBLOCK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   991          } else if ((s32_t)(sys_now() - conn->current_msg->msg.sd.time_started) >=
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   992                     (conn->linger * 1000)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   993            /* data left but linger timeout has expired (this happens on further
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   994               calls to this function through poll_tcp */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   995            tcp_abort(tpcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   996            tpcb = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   997          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   998            /* data left -> need to wait for ACK after successful close */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	   999            linger_wait_required = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1000          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1001        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1002      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1003      if ((err == ERR_OK) && (tpcb != NULL))
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1004  #endif /* LWIP_SO_LINGER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1005      {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1006        err = tcp_close(tpcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1007      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1008    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1009      err = tcp_shutdown(tpcb, shut_rx, shut_tx);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1010    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1011    if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1012      close_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1013  #if LWIP_SO_LINGER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1014      if (linger_wait_required) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1015        /* wait for ACK of all unsent/unacked data by just getting called again */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1016        close_finished = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1017        err = ERR_INPROGRESS;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1018      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1019  #endif /* LWIP_SO_LINGER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1020    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1021      if (err == ERR_MEM) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1022        /* Closing failed because of memory shortage, try again later. Even for
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1023           nonblocking netconns, we have to wait since no standard socket application
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1024           is prepared for close failing because of resource shortage.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1025           Check the timeout: this is kind of an lwip addition to the standard sockets:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1026           we wait for some time when failing to allocate a segment for the FIN */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1027  #if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1028        s32_t close_timeout = LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1029  #if LWIP_SO_SNDTIMEO
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1030        if (conn->send_timeout > 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1031          close_timeout = conn->send_timeout;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1032        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1033  #endif /* LWIP_SO_SNDTIMEO */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1034  #if LWIP_SO_LINGER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1035        if (conn->linger >= 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1036          /* use linger timeout (seconds) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1037          close_timeout = conn->linger * 1000U;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1038        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1039  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1040        if ((s32_t)(sys_now() - conn->current_msg->msg.sd.time_started) >= close_timeout) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1041  #else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1042        if (conn->current_msg->msg.sd.polls_left == 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1043  #endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1044          close_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1045          if (shut_close) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1046            /* in this case, we want to RST the connection */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1047            tcp_abort(tpcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1048            err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1049          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1050        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1051      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1052        /* Closing failed for a non-memory error: give up */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1053        close_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1054      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1055    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1056    if (close_finished) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1057      /* Closing done (succeeded, non-memory error, nonblocking error or timeout) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1058      sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1059      conn->current_msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1060      conn->current_msg = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1061      conn->state = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1062      if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1063        if (shut_close) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1064          /* Set back some callback pointers as conn is going away */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1065          conn->pcb.tcp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1066          /* Trigger select() in socket layer. Make sure everybody notices activity
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1067           on the connection, error first! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1068          API_EVENT(conn, NETCONN_EVT_ERROR, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1069        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1070        if (shut_rx) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1071          API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1072        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1073        if (shut_tx) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1074          API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1075        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1076      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1077  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1078      if (delayed)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1079  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1080      {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1081        /* wake up the application task */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1082        sys_sem_signal(op_completed_sem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1083      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1084      return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1085    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1086    if (!close_finished) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1087      /* Closing failed and we want to wait: restore some of the callbacks */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1088      /* Closing of listen pcb will never fail! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1089      LWIP_ASSERT("Closing a listen pcb may not fail!", (tpcb->state != LISTEN));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1090      if (shut_tx) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1091        tcp_sent(tpcb, sent_tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1092      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1093      /* when waiting for close, set up poll interval to 500ms */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1094      tcp_poll(tpcb, poll_tcp, 1);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1095      tcp_err(tpcb, err_tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1096      tcp_arg(tpcb, conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1097      /* don't restore recv callback: we don't want to receive any more data */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1098    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1099    /* If closing didn't succeed, we get called again either
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1100       from poll_tcp or from sent_tcp */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1101    LWIP_ASSERT("err != ERR_OK", err != ERR_OK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1102    return err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1103  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1104  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1105  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1106  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1107   * Delete the pcb inside a netconn.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1108   * Called from netconn_delete.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1109   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1110   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1111   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1112  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1113  lwip_netconn_do_delconn(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1114  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1115    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1116  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1117    enum netconn_state state = msg->conn->state;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1118    LWIP_ASSERT("netconn state error", /* this only happens for TCP netconns */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1119                (state == NETCONN_NONE) || (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1120  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1121    /* In full duplex mode, blocking write/connect is aborted with ERR_CLSD */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1122    if (state != NETCONN_NONE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1123      if ((state == NETCONN_WRITE) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1124          ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1125        /* close requested, abort running write/connect */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1126        sys_sem_t *op_completed_sem;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1127        LWIP_ASSERT("msg->conn->current_msg != NULL", msg->conn->current_msg != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1128        op_completed_sem = LWIP_API_MSG_SEM(msg->conn->current_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1129        msg->conn->current_msg->err = ERR_CLSD;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1130        msg->conn->current_msg = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1131        msg->conn->state = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1132        sys_sem_signal(op_completed_sem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1133      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1134    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1135  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1136    if (((state != NETCONN_NONE) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1137         (state != NETCONN_LISTEN) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1138         (state != NETCONN_CONNECT)) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1139        ((state == NETCONN_CONNECT) && !IN_NONBLOCKING_CONNECT(msg->conn))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1140      /* This means either a blocking write or blocking connect is running
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1141         (nonblocking write returns and sets state to NONE) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1142      msg->err = ERR_INPROGRESS;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1143    } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1144  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1145    {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1146      LWIP_ASSERT("blocking connect in progress",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1147                  (state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1148      msg->err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1149  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1150      /* Mark mboxes invalid */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1151      netconn_mark_mbox_invalid(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1152  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1153      netconn_drain(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1154  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1155  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1156      if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1157  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1158        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1159  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1160          case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1161            raw_remove(msg->conn->pcb.raw);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1162            break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1163  #endif /* LWIP_RAW */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1164  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1165          case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1166            msg->conn->pcb.udp->recv_arg = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1167            udp_remove(msg->conn->pcb.udp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1168            break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1169  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1170  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1171          case NETCONN_TCP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1172            LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1173            msg->conn->state = NETCONN_CLOSE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1174            msg->msg.sd.shut = NETCONN_SHUT_RDWR;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1175            msg->conn->current_msg = msg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1176  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1177            if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1178              LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1179              UNLOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1180              sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1181              LOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1182              LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1183            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1184  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1185            lwip_netconn_do_close_internal(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1186  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1187            /* API_EVENT is called inside lwip_netconn_do_close_internal, before releasing
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1188               the application thread, so we can return at this point! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1189            return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1190  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1191          default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1192            break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1193        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1194        msg->conn->pcb.tcp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1195      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1196      /* tcp netconns don't come here! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1197  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1198      /* @todo: this lets select make the socket readable and writable,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1199         which is wrong! errfd instead? */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1200      API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1201      API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1202    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1203    if (sys_sem_valid(LWIP_API_MSG_SEM(msg))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1204      TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1205    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1206  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1207  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1208  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1209   * Bind a pcb contained in a netconn
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1210   * Called from netconn_bind.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1211   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1212   * @param m the api_msg pointing to the connection and containing
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1213   *          the IP address and port to bind to
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1214   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1215  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1216  lwip_netconn_do_bind(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1217  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1218    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1219    err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1220  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1221    if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1222      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1223  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1224        case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1225          err = raw_bind(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1226          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1227  #endif /* LWIP_RAW */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1228  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1229        case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1230          err = udp_bind(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1231          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1232  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1233  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1234        case NETCONN_TCP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1235          err = tcp_bind(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1236          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1237  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1238        default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1239          err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1240          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1241      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1242    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1243      err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1244    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1245    msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1246    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1247  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1248  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1249   * Bind a pcb contained in a netconn to an interface
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1250   * Called from netconn_bind_if.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1251   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1252   * @param m the api_msg pointing to the connection and containing
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1253   *          the IP address and port to bind to
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1254   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1255  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1256  lwip_netconn_do_bind_if(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1257  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1258    struct netif *netif;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1259    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1260    err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1261  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1262    netif = netif_get_by_index(msg->msg.bc.if_idx);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1263  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1264    if ((netif != NULL) && (msg->conn->pcb.tcp != NULL)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1265      err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1266      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1267  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1268        case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1269          raw_bind_netif(msg->conn->pcb.raw, netif);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1270          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1271  #endif /* LWIP_RAW */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1272  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1273        case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1274          udp_bind_netif(msg->conn->pcb.udp, netif);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1275          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1276  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1277  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1278        case NETCONN_TCP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1279          tcp_bind_netif(msg->conn->pcb.tcp, netif);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1280          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1281  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1282        default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1283          err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1284          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1285      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1286    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1287      err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1288    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1289    msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1290    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1291  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1292  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1293  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1294  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1295   * TCP callback function if a connection (opened by tcp_connect/lwip_netconn_do_connect) has
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1296   * been established (or reset by the remote host).
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1297   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1298   * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1299   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1300  static err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1301  lwip_netconn_do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1302  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1303    struct netconn *conn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1304    int was_blocking;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1305    sys_sem_t *op_completed_sem = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1306  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1307    LWIP_UNUSED_ARG(pcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1308  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1309    conn = (struct netconn *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1310  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1311    if (conn == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1312      return ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1313    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1314  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1315    LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1316    LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1317                (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1318  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1319    if (conn->current_msg != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1320      conn->current_msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1321      op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1322    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1323    if ((NETCONNTYPE_GROUP(conn->type) == NETCONN_TCP) && (err == ERR_OK)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1324      setup_tcp(conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1325    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1326    was_blocking = !IN_NONBLOCKING_CONNECT(conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1327    SET_NONBLOCKING_CONNECT(conn, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1328    LWIP_ASSERT("blocking connect state error",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1329                (was_blocking && op_completed_sem != NULL) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1330                (!was_blocking && op_completed_sem == NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1331    conn->current_msg = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1332    conn->state = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1333    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1334  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1335    if (was_blocking) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1336      sys_sem_signal(op_completed_sem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1337    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1338    return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1339  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1340  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1341  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1342  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1343   * Connect a pcb contained inside a netconn
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1344   * Called from netconn_connect.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1345   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1346   * @param m the api_msg pointing to the connection and containing
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1347   *          the IP address and port to connect to
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1348   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1349  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1350  lwip_netconn_do_connect(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1351  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1352    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1353    err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1354  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1355    if (msg->conn->pcb.tcp == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1356      /* This may happen when calling netconn_connect() a second time */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1357      err = ERR_CLSD;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1358    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1359      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1360  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1361        case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1362          err = raw_connect(msg->conn->pcb.raw, API_EXPR_REF(msg->msg.bc.ipaddr));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1363          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1364  #endif /* LWIP_RAW */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1365  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1366        case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1367          err = udp_connect(msg->conn->pcb.udp, API_EXPR_REF(msg->msg.bc.ipaddr), msg->msg.bc.port);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1368          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1369  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1370  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1371        case NETCONN_TCP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1372          /* Prevent connect while doing any other action. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1373          if (msg->conn->state == NETCONN_CONNECT) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1374            err = ERR_ALREADY;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1375          } else if (msg->conn->state != NETCONN_NONE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1376            err = ERR_ISCONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1377          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1378            setup_tcp(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1379            err = tcp_connect(msg->conn->pcb.tcp, API_EXPR_REF(msg->msg.bc.ipaddr),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1380                              msg->msg.bc.port, lwip_netconn_do_connected);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1381            if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1382              u8_t non_blocking = netconn_is_nonblocking(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1383              msg->conn->state = NETCONN_CONNECT;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1384              SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1385              if (non_blocking) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1386                err = ERR_INPROGRESS;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1387              } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1388                msg->conn->current_msg = msg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1389                /* sys_sem_signal() is called from lwip_netconn_do_connected (or err_tcp()),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1390                   when the connection is established! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1391  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1392                LWIP_ASSERT("state!", msg->conn->state == NETCONN_CONNECT);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1393                UNLOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1394                sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1395                LOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1396                LWIP_ASSERT("state!", msg->conn->state != NETCONN_CONNECT);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1397  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1398                return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1399              }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1400            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1401          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1402          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1403  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1404        default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1405          LWIP_ERROR("Invalid netconn type", 0, do {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1406            err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1407          } while (0));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1408          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1409      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1410    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1411    msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1412    /* For all other protocols, netconn_connect() calls netconn_apimsg(),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1413       so use TCPIP_APIMSG_ACK() here. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1414    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1415  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1416  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1417  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1418   * Disconnect a pcb contained inside a netconn
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1419   * Only used for UDP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1420   * Called from netconn_disconnect.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1421   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1422   * @param m the api_msg pointing to the connection to disconnect
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1423   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1424  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1425  lwip_netconn_do_disconnect(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1426  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1427    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1428  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1429  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1430    if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1431      udp_disconnect(msg->conn->pcb.udp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1432      msg->err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1433    } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1434  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1435    {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1436      msg->err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1437    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1438    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1439  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1440  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1441  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1442  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1443   * Set a TCP pcb contained in a netconn into listen mode
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1444   * Called from netconn_listen.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1445   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1446   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1447   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1448  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1449  lwip_netconn_do_listen(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1450  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1451    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1452    err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1453  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1454    if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1455      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1456        if (msg->conn->state == NETCONN_NONE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1457          struct tcp_pcb *lpcb;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1458          if (msg->conn->pcb.tcp->state != CLOSED) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1459            /* connection is not closed, cannot listen */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1460            err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1461          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1462            u8_t backlog;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1463  #if TCP_LISTEN_BACKLOG
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1464            backlog = msg->msg.lb.backlog;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1465  #else  /* TCP_LISTEN_BACKLOG */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1466            backlog = TCP_DEFAULT_LISTEN_BACKLOG;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1467  #endif /* TCP_LISTEN_BACKLOG */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1468  #if LWIP_IPV4 && LWIP_IPV6
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1469            /* "Socket API like" dual-stack support: If IP to listen to is IP6_ADDR_ANY,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1470              * and NETCONN_FLAG_IPV6_V6ONLY is NOT set, use IP_ANY_TYPE to listen
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1471              */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1472            if (ip_addr_cmp(&msg->conn->pcb.ip->local_ip, IP6_ADDR_ANY) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1473                (netconn_get_ipv6only(msg->conn) == 0)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1474              /* change PCB type to IPADDR_TYPE_ANY */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1475              IP_SET_TYPE_VAL(msg->conn->pcb.tcp->local_ip,  IPADDR_TYPE_ANY);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1476              IP_SET_TYPE_VAL(msg->conn->pcb.tcp->remote_ip, IPADDR_TYPE_ANY);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1477            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1478  #endif /* LWIP_IPV4 && LWIP_IPV6 */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1479  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1480            lpcb = tcp_listen_with_backlog_and_err(msg->conn->pcb.tcp, backlog, &err);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1481  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1482            if (lpcb == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1483              /* in this case, the old pcb is still allocated */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1484            } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1485              /* delete the recvmbox and allocate the acceptmbox */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1486              if (sys_mbox_valid(&msg->conn->recvmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1487                /** @todo: should we drain the recvmbox here? */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1488                sys_mbox_free(&msg->conn->recvmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1489                sys_mbox_set_invalid(&msg->conn->recvmbox);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1490              }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1491              err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1492              if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1493                err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1494              }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1495              if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1496                msg->conn->state = NETCONN_LISTEN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1497                msg->conn->pcb.tcp = lpcb;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1498                tcp_arg(msg->conn->pcb.tcp, msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1499                tcp_accept(msg->conn->pcb.tcp, accept_function);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1500              } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1501                /* since the old pcb is already deallocated, free lpcb now */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1502                tcp_close(lpcb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1503                msg->conn->pcb.tcp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1504              }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1505            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1506          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1507        } else if (msg->conn->state == NETCONN_LISTEN) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1508          /* already listening, allow updating of the backlog */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1509          err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1510          tcp_backlog_set(msg->conn->pcb.tcp, msg->msg.lb.backlog);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1511        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1512          err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1513        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1514      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1515        err = ERR_ARG;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1516      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1517    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1518      err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1519    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1520    msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1521    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1522  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1523  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1524  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1525  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1526   * Send some data on a RAW or UDP pcb contained in a netconn
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1527   * Called from netconn_send
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1528   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1529   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1530   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1531  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1532  lwip_netconn_do_send(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1533  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1534    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1535  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1536    err_t err = netconn_err(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1537    if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1538      if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1539        switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1540  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1541          case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1542            if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1543              err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1544            } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1545              err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1546            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1547            break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1548  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1549  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1550          case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1551  #if LWIP_CHECKSUM_ON_COPY
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1552            if (ip_addr_isany(&msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1553              err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1554                                    msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1555            } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1556              err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1557                                      &msg->msg.b->addr, msg->msg.b->port,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1558                                      msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1559            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1560  #else /* LWIP_CHECKSUM_ON_COPY */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1561            if (ip_addr_isany_val(msg->msg.b->addr) || IP_IS_ANY_TYPE_VAL(msg->msg.b->addr)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1562              err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1563            } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1564              err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1565            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1566  #endif /* LWIP_CHECKSUM_ON_COPY */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1567            break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1568  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1569          default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1570            err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1571            break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1572        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1573      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1574        err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1575      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1576    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1577    msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1578    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1579  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1580  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1581  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1582  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1583   * Indicate data has been received from a TCP pcb contained in a netconn
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1584   * Called from netconn_recv
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1585   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1586   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1587   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1588  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1589  lwip_netconn_do_recv(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1590  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1591    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1592  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1593    msg->err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1594    if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1595      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1596        size_t remaining = msg->msg.r.len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1597        do {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1598          u16_t recved = (u16_t)((remaining > 0xffff) ? 0xffff : remaining);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1599          tcp_recved(msg->conn->pcb.tcp, recved);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1600          remaining -= recved;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1601        } while (remaining != 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1602      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1603    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1604    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1605  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1606  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1607  #if TCP_LISTEN_BACKLOG
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1608  /** Indicate that a TCP pcb has been accepted
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1609   * Called from netconn_accept
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1610   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1611   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1612   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1613  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1614  lwip_netconn_do_accepted(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1615  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1616    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1617  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1618    msg->err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1619    if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1620      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1621        tcp_backlog_accepted(msg->conn->pcb.tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1622      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1623    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1624    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1625  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1626  #endif /* TCP_LISTEN_BACKLOG */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1627  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1628  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1629   * See if more data needs to be written from a previous call to netconn_write.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1630   * Called initially from lwip_netconn_do_write. If the first call can't send all data
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1631   * (because of low memory or empty send-buffer), this function is called again
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1632   * from sent_tcp() or poll_tcp() to send more data. If all data is sent, the
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1633   * blocking application thread (waiting in netconn_write) is released.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1634   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1635   * @param conn netconn (that is currently in state NETCONN_WRITE) to process
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1636   * @return ERR_OK
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1637   *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1638   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1639  static err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1640  lwip_netconn_do_writemore(struct netconn *conn  WRITE_DELAYED_PARAM)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1641  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1642    err_t err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1643    const void *dataptr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1644    u16_t len, available;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1645    u8_t write_finished = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1646    size_t diff;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1647    u8_t dontblock;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1648    u8_t apiflags;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1649    u8_t write_more;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1650  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1651    LWIP_ASSERT("conn != NULL", conn != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1652    LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1653    LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1654    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1655    LWIP_ASSERT("conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1656                conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1657    LWIP_ASSERT("conn->current_msg->msg.w.vector_cnt > 0", conn->current_msg->msg.w.vector_cnt > 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1658  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1659    apiflags = conn->current_msg->msg.w.apiflags;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1660    dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1661  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1662  #if LWIP_SO_SNDTIMEO
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1663    if ((conn->send_timeout != 0) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1664        ((s32_t)(sys_now() - conn->current_msg->msg.w.time_started) >= conn->send_timeout)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1665      write_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1666      if (conn->current_msg->msg.w.offset == 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1667        /* nothing has been written */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1668        err = ERR_WOULDBLOCK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1669      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1670        /* partial write */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1671        err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1672      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1673    } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1674  #endif /* LWIP_SO_SNDTIMEO */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1675    {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1676      do {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1677        dataptr = (const u8_t *)conn->current_msg->msg.w.vector->ptr + conn->current_msg->msg.w.vector_off;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1678        diff = conn->current_msg->msg.w.vector->len - conn->current_msg->msg.w.vector_off;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1679        if (diff > 0xffffUL) { /* max_u16_t */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1680          len = 0xffff;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1681          apiflags |= TCP_WRITE_FLAG_MORE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1682        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1683          len = (u16_t)diff;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1684        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1685        available = tcp_sndbuf(conn->pcb.tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1686        if (available < len) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1687          /* don't try to write more than sendbuf */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1688          len = available;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1689          if (dontblock) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1690            if (!len) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1691              /* set error according to partial write or not */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1692              err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1693              goto err_mem;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1694            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1695          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1696            apiflags |= TCP_WRITE_FLAG_MORE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1697          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1698        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1699        LWIP_ASSERT("lwip_netconn_do_writemore: invalid length!",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1700                    ((conn->current_msg->msg.w.vector_off + len) <= conn->current_msg->msg.w.vector->len));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1701        /* we should loop around for more sending in the following cases:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1702             1) We couldn't finish the current vector because of 16-bit size limitations.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1703                tcp_write() and tcp_sndbuf() both are limited to 16-bit sizes
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1704             2) We are sending the remainder of the current vector and have more */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1705        if ((len == 0xffff && diff > 0xffffUL) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1706            (len == (u16_t)diff && conn->current_msg->msg.w.vector_cnt > 1)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1707          write_more = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1708          apiflags |= TCP_WRITE_FLAG_MORE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1709        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1710          write_more = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1711        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1712        err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1713        if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1714          conn->current_msg->msg.w.offset += len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1715          conn->current_msg->msg.w.vector_off += len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1716          /* check if current vector is finished */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1717          if (conn->current_msg->msg.w.vector_off == conn->current_msg->msg.w.vector->len) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1718            conn->current_msg->msg.w.vector_cnt--;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1719            /* if we have additional vectors, move on to them */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1720            if (conn->current_msg->msg.w.vector_cnt > 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1721              conn->current_msg->msg.w.vector++;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1722              conn->current_msg->msg.w.vector_off = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1723            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1724          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1725        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1726      } while (write_more && err == ERR_OK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1727      /* if OK or memory error, check available space */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1728      if ((err == ERR_OK) || (err == ERR_MEM)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1729  err_mem:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1730        if (dontblock && (conn->current_msg->msg.w.offset < conn->current_msg->msg.w.len)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1731          /* non-blocking write did not write everything: mark the pcb non-writable
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1732             and let poll_tcp check writable space to mark the pcb writable again */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1733          API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1734          conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1735        } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1736                   (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1737          /* The queued byte- or pbuf-count exceeds the configured low-water limit,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1738             let select mark this pcb as non-writable. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1739          API_EVENT(conn, NETCONN_EVT_SENDMINUS, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1740        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1741      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1742  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1743      if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1744        err_t out_err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1745        if ((conn->current_msg->msg.w.offset == conn->current_msg->msg.w.len) || dontblock) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1746          /* return sent length (caller reads length from msg.w.offset) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1747          write_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1748        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1749        out_err = tcp_output(conn->pcb.tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1750        if (out_err == ERR_RTE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1751          /* If tcp_output fails because no route is found,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1752             don't try writing any more but return the error
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1753             to the application thread. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1754          err = out_err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1755          write_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1756        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1757      } else if (err == ERR_MEM) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1758        /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1759           For blocking sockets, we do NOT return to the application
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1760           thread, since ERR_MEM is only a temporary error! Non-blocking
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1761           will remain non-writable until sent_tcp/poll_tcp is called */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1762  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1763        /* tcp_write returned ERR_MEM, try tcp_output anyway */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1764        err_t out_err = tcp_output(conn->pcb.tcp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1765        if (out_err == ERR_RTE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1766          /* If tcp_output fails because no route is found,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1767             don't try writing any more but return the error
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1768             to the application thread. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1769          err = out_err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1770          write_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1771        } else if (dontblock) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1772          /* non-blocking write is done on ERR_MEM, set error according
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1773             to partial write or not */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1774          err = (conn->current_msg->msg.w.offset == 0) ? ERR_WOULDBLOCK : ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1775          write_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1776        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1777      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1778        /* On errors != ERR_MEM, we don't try writing any more but return
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1779           the error to the application thread. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1780        write_finished = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1781      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1782    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1783    if (write_finished) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1784      /* everything was written: set back connection state
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1785         and back to application task */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1786      sys_sem_t *op_completed_sem = LWIP_API_MSG_SEM(conn->current_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1787      conn->current_msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1788      conn->current_msg = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1789      conn->state = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1790  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1791      if (delayed)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1792  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1793      {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1794        sys_sem_signal(op_completed_sem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1795      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1796    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1797  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1798    else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1799      return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1800    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1801  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1802    return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1803  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1804  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1805  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1806  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1807   * Send some data on a TCP pcb contained in a netconn
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1808   * Called from netconn_write
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1809   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1810   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1811   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1812  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1813  lwip_netconn_do_write(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1814  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1815    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1816  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1817    err_t err = netconn_err(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1818    if (err == ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1819      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1820  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1821        if (msg->conn->state != NETCONN_NONE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1822          /* netconn is connecting, closing or in blocking write */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1823          err = ERR_INPROGRESS;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1824        } else if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1825          msg->conn->state = NETCONN_WRITE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1826          /* set all the variables used by lwip_netconn_do_writemore */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1827          LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1828          LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1829          msg->conn->current_msg = msg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1830  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1831          if (lwip_netconn_do_writemore(msg->conn, 0) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1832            LWIP_ASSERT("state!", msg->conn->state == NETCONN_WRITE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1833            UNLOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1834            sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1835            LOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1836            LWIP_ASSERT("state!", msg->conn->state != NETCONN_WRITE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1837          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1838  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1839          lwip_netconn_do_writemore(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1840  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1841          /* for both cases: if lwip_netconn_do_writemore was called, don't ACK the APIMSG
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1842             since lwip_netconn_do_writemore ACKs it! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1843          return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1844        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1845          err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1846        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1847  #else /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1848        err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1849  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1850  #if (LWIP_UDP || LWIP_RAW)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1851      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1852        err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1853  #endif /* (LWIP_UDP || LWIP_RAW) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1854      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1855    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1856    msg->err = err;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1857    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1858  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1859  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1860  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1861   * Return a connection's local or remote address
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1862   * Called from netconn_getaddr
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1863   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1864   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1865   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1866  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1867  lwip_netconn_do_getaddr(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1868  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1869    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1870  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1871    if (msg->conn->pcb.ip != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1872      if (msg->msg.ad.local) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1873        ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1874                     msg->conn->pcb.ip->local_ip);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1875      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1876        ip_addr_copy(API_EXPR_DEREF(msg->msg.ad.ipaddr),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1877                     msg->conn->pcb.ip->remote_ip);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1878      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1879  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1880      msg->err = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1881      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1882  #if LWIP_RAW
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1883        case NETCONN_RAW:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1884          if (msg->msg.ad.local) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1885            API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1886          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1887            /* return an error as connecting is only a helper for upper layers */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1888            msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1889          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1890          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1891  #endif /* LWIP_RAW */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1892  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1893        case NETCONN_UDP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1894          if (msg->msg.ad.local) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1895            API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1896          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1897            if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1898              msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1899            } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1900              API_EXPR_DEREF(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1901            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1902          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1903          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1904  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1905  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1906        case NETCONN_TCP:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1907          if ((msg->msg.ad.local == 0) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1908              ((msg->conn->pcb.tcp->state == CLOSED) || (msg->conn->pcb.tcp->state == LISTEN))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1909            /* pcb is not connected and remote name is requested */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1910            msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1911          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1912            API_EXPR_DEREF(msg->msg.ad.port) = (msg->msg.ad.local ? msg->conn->pcb.tcp->local_port : msg->conn->pcb.tcp->remote_port);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1913          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1914          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1915  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1916        default:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1917          LWIP_ASSERT("invalid netconn_type", 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1918          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1919      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1920    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1921      msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1922    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1923    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1924  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1925  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1926  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1927   * Close or half-shutdown a TCP pcb contained in a netconn
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1928   * Called from netconn_close
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1929   * In contrast to closing sockets, the netconn is not deallocated.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1930   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1931   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1932   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1933  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1934  lwip_netconn_do_close(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1935  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1936    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1937  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1938  #if LWIP_TCP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1939    enum netconn_state state = msg->conn->state;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1940    /* First check if this is a TCP netconn and if it is in a correct state
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1941        (LISTEN doesn't support half shutdown) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1942    if ((msg->conn->pcb.tcp != NULL) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1943        (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_TCP) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1944        ((msg->msg.sd.shut == NETCONN_SHUT_RDWR) || (state != NETCONN_LISTEN))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1945      /* Check if we are in a connected state */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1946      if (state == NETCONN_CONNECT) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1947        /* TCP connect in progress: cannot shutdown */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1948        msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1949      } else if (state == NETCONN_WRITE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1950  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1951        if (msg->msg.sd.shut & NETCONN_SHUT_WR) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1952          /* close requested, abort running write */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1953          sys_sem_t *write_completed_sem;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1954          LWIP_ASSERT("msg->conn->current_msg != NULL", msg->conn->current_msg != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1955          write_completed_sem = LWIP_API_MSG_SEM(msg->conn->current_msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1956          msg->conn->current_msg->err = ERR_CLSD;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1957          msg->conn->current_msg = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1958          msg->conn->state = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1959          state = NETCONN_NONE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1960          sys_sem_signal(write_completed_sem);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1961        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1962          LWIP_ASSERT("msg->msg.sd.shut == NETCONN_SHUT_RD", msg->msg.sd.shut == NETCONN_SHUT_RD);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1963          /* In this case, let the write continue and do not interfere with
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1964             conn->current_msg or conn->state! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1965          msg->err = tcp_shutdown(msg->conn->pcb.tcp, 1, 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1966        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1967      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1968      if (state == NETCONN_NONE) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1969  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1970        msg->err = ERR_INPROGRESS;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1971      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1972  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1973        if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1974  #if LWIP_NETCONN_FULLDUPLEX
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1975          /* Mark mboxes invalid */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1976          netconn_mark_mbox_invalid(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1977  #else /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1978          netconn_drain(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1979  #endif /* LWIP_NETCONN_FULLDUPLEX */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1980        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1981        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1982        msg->conn->state = NETCONN_CLOSE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1983        msg->conn->current_msg = msg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1984  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1985        if (lwip_netconn_do_close_internal(msg->conn, 0) != ERR_OK) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1986          LWIP_ASSERT("state!", msg->conn->state == NETCONN_CLOSE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1987          UNLOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1988          sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1989          LOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1990          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1991        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1992  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1993        lwip_netconn_do_close_internal(msg->conn);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1994  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1995        /* for tcp netconns, lwip_netconn_do_close_internal ACKs the message */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1996        return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1997      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1998    } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  1999  #endif /* LWIP_TCP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2000    {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2001      msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2002    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2003    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2004  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2005  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2006  #if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2007  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2008   * Join multicast groups for UDP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2009   * Called from netconn_join_leave_group
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2010   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2011   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2012   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2013  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2014  lwip_netconn_do_join_leave_group(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2015  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2016    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2017  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2018    msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2019    if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2020      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2021  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2022  #if LWIP_IPV6 && LWIP_IPV6_MLD
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2023        if (NETCONNTYPE_ISIPV6(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2024          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2025            msg->err = mld6_joingroup(ip_2_ip6(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2026                                      ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2027          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2028            msg->err = mld6_leavegroup(ip_2_ip6(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2029                                       ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2030          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2031        } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2032  #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2033        {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2034  #if LWIP_IGMP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2035          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2036            msg->err = igmp_joingroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2037                                      ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2038          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2039            msg->err = igmp_leavegroup(ip_2_ip4(API_EXPR_REF(msg->msg.jl.netif_addr)),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2040                                       ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2041          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2042  #endif /* LWIP_IGMP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2043        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2044  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2045  #if (LWIP_TCP || LWIP_RAW)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2046      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2047        msg->err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2048  #endif /* (LWIP_TCP || LWIP_RAW) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2049      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2050    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2051    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2052  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2053  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2054   * Join multicast groups for UDP netconns.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2055   * Called from netconn_join_leave_group_netif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2056   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2057   * @param m the api_msg pointing to the connection
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2058   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2059  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2060  lwip_netconn_do_join_leave_group_netif(void *m)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2061  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2062    struct api_msg *msg = (struct api_msg *)m;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2063    struct netif *netif;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2064  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2065    netif = netif_get_by_index(msg->msg.jl.if_idx);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2066    if (netif == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2067      msg->err = ERR_IF;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2068      goto done;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2069    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2070  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2071    msg->err = ERR_CONN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2072    if (msg->conn->pcb.tcp != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2073      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2074  #if LWIP_UDP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2075  #if LWIP_IPV6 && LWIP_IPV6_MLD
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2076        if (NETCONNTYPE_ISIPV6(msg->conn->type)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2077          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2078            msg->err = mld6_joingroup_netif(netif,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2079                                            ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2080          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2081            msg->err = mld6_leavegroup_netif(netif,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2082                                             ip_2_ip6(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2083          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2084        } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2085  #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2086        {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2087  #if LWIP_IGMP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2088          if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2089            msg->err = igmp_joingroup_netif(netif,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2090                                            ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2091          } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2092            msg->err = igmp_leavegroup_netif(netif,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2093                                             ip_2_ip4(API_EXPR_REF(msg->msg.jl.multiaddr)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2094          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2095  #endif /* LWIP_IGMP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2096        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2097  #endif /* LWIP_UDP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2098  #if (LWIP_TCP || LWIP_RAW)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2099      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2100        msg->err = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2101  #endif /* (LWIP_TCP || LWIP_RAW) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2102      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2103    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2104  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2105  done:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2106    TCPIP_APIMSG_ACK(msg);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2107  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2108  #endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2109  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2110  #if LWIP_DNS
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2111  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2112   * Callback function that is called when DNS name is resolved
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2113   * (or on timeout). A waiting application thread is waked up by
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2114   * signaling the semaphore.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2115   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2116  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2117  lwip_netconn_do_dns_found(const char *name, const ip_addr_t *ipaddr, void *arg)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2118  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2119    struct dns_api_msg *msg = (struct dns_api_msg *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2120  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2121    /* we trust the internal implementation to be correct :-) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2122    LWIP_UNUSED_ARG(name);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2123  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2124    if (ipaddr == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2125      /* timeout or memory error */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2126      API_EXPR_DEREF(msg->err) = ERR_VAL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2127    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2128      /* address was resolved */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2129      API_EXPR_DEREF(msg->err) = ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2130      API_EXPR_DEREF(msg->addr) = *ipaddr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2131    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2132    /* wake up the application task waiting in netconn_gethostbyname */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2133    sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2134  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2135  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2136  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2137   * Execute a DNS query
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2138   * Called from netconn_gethostbyname
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2139   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2140   * @param arg the dns_api_msg pointing to the query
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2141   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2142  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2143  lwip_netconn_do_gethostbyname(void *arg)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2144  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2145    struct dns_api_msg *msg = (struct dns_api_msg *)arg;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2146    u8_t addrtype =
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2147  #if LWIP_IPV4 && LWIP_IPV6
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2148      msg->dns_addrtype;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2149  #else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2150      LWIP_DNS_ADDRTYPE_DEFAULT;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2151  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2152  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2153    API_EXPR_DEREF(msg->err) = dns_gethostbyname_addrtype(msg->name,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2154                               API_EXPR_REF(msg->addr), lwip_netconn_do_dns_found, msg, addrtype);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2155  #if LWIP_TCPIP_CORE_LOCKING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2156    /* For core locking, only block if we need to wait for answer/timeout */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2157    if (API_EXPR_DEREF(msg->err) == ERR_INPROGRESS) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2158      UNLOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2159      sys_sem_wait(API_EXPR_REF_SEM(msg->sem));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2160      LOCK_TCPIP_CORE();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2161      LWIP_ASSERT("do_gethostbyname still in progress!!", API_EXPR_DEREF(msg->err) != ERR_INPROGRESS);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2162    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2163  #else /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2164    if (API_EXPR_DEREF(msg->err) != ERR_INPROGRESS) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2165      /* on error or immediate success, wake up the application
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2166       * task waiting in netconn_gethostbyname */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2167      sys_sem_signal(API_EXPR_REF_SEM(msg->sem));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2168    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2169  #endif /* LWIP_TCPIP_CORE_LOCKING */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2170  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2171  #endif /* LWIP_DNS */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2172  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\api\api_msg.c	  2173  #endif /* LWIP_NETCONN */

	; Module end
