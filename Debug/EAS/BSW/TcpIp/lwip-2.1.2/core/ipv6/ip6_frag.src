	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 18041957 SN 09003395"
	.compiler_invocation	"ctc -f cc28936a --dep-file=EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6\\.ip6_frag.o.d -c99 --fp-model=3cflnrSTz -D__CPU__=tc39x -D__CPU_TC39X__ --core=tc1.6.2 --fp-model=+float -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\EB_Cfg -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\EB_Cfg\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\EB_Cfg\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Autosar_Srv -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Autosar_Srv\\AS440 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Cfg_Ssw -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Cfg_Ssw\\TC39B -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Integration -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Irq\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Platform -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Platform\\AS440 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Sfr -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Sfr\\TC39xB -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Sfr\\TC39xB\\_Reg -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Ssw -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Ssw\\TC39B -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Ssw\\TC39B\\Tricore -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Adc\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Can_17_McmCan\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Dio\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Eth_17_GEthMacV2\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fee\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Fls_17_Dmu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Gpt\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\I2c\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Icu_17_TimerIp\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc\\inc\\AS440 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\McalLib\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Mcu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Ocu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Port\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Pwm_17_GtmCcu6\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Smu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Spi\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Stm\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Uart\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu\\ssc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu\\ssc\\inc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Tricore\\Wdg_17_Scu\\ssc\\src -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Lib -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\App_Func -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\demo -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Adc_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Gtm_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\AscLin_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Can_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\EthV2_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Irq\\Stm_Irq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Srval\\Main -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\APP -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\BswM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanNm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanSm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanTp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\CanTSyn -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Com -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\ComM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Common -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Crc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Dcm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Dem -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Det -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\DoIP -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EcuM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Eth -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthSM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthTrcv -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\EthTSyn -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\FiM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\FlsTst -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\MemIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Nm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\NvM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\OS -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\OS\\Kernel -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\OS\\Portable -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\PduR -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\RamTst -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\SoAd -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\StbM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\api -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\arch -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv4 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6 -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix\\arpa -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix\\net -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\posix\\sys -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\compat\\stdc -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip\\apps -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip\\priv -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip\\prot -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\netif -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\netif\\ppp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\netif\\ppp\\polarssl -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\netif -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\netif\\ppp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\netif\\ppp\\polarssl -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\UdpNm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\WdgIf -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\WdgM -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Cal -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Daq -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Pag -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Pgm -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\Std -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\Xcp\\XcpOnEth -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Callout -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Config -IF:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Library\\Vfx_ComE2E -g2 --make-target=EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6\\ip6_frag.o -t2 --language=-gcc,-volatile,+strings,-kanji --default-near-size=0 -O1 --default-a1-size=0 --default-a0-size=0 --source --align=0 --switch=auto --error-limit=42 -o EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6\\ip6_frag.src ..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6\\ip6_frag.c"
	.compiler_name		"ctc"
	;source	'..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6\\ip6_frag.c'

	
$TC162
	
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L3:
	.word	5428
	.half	3
	.word	.L4
	.byte	4
.L2:
	.byte	1
	.byte	'..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6\\ip6_frag.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Debug\\',0,12,1
	.word	.L5
	.byte	2,1,3
	.word	172
	.byte	4
	.byte	'__codeptr',0,1,1,1
	.word	174
	.byte	5
	.byte	'unsigned char',0,1,8,4
	.byte	'boolean',0,2,102,29
	.word	197
	.byte	4
	.byte	'uint8',0,2,106,29
	.word	197
	.byte	5
	.byte	'unsigned short int',0,2,7,4
	.byte	'uint16',0,2,110,29
	.word	244
	.byte	5
	.byte	'unsigned long int',0,4,7,4
	.byte	'uint32',0,2,114,29
	.word	281
	.byte	4
	.byte	'Std_ReturnType',0,3,109,16
	.word	197
	.byte	4
	.byte	'PduIdType',0,4,37,21
	.word	197
	.byte	4
	.byte	'PduLengthType',0,4,41,22
	.word	244
	.byte	6,5,101,9,1,7
	.byte	'BUFREQ_OK',0,0,7
	.byte	'BUFREQ_E_NOT_OK',0,1,7
	.byte	'BUFREQ_E_BUSY',0,2,7
	.byte	'BUFREQ_E_OVFL',0,3,0,4
	.byte	'BufReq_ReturnType',0,5,107,3
	.word	380
	.byte	3
	.word	197
	.byte	4
	.byte	'SduDataPtrType',0,5,189,1,40
	.word	474
	.byte	6,5,204,1,9,1,7
	.byte	'TP_DATACONF',0,0,7
	.byte	'TP_DATARETRY',0,1,7
	.byte	'TP_CONFPENDING',0,2,0,4
	.byte	'TpDataStateType',0,5,216,1,3
	.word	503
	.byte	4
	.byte	'TcpIp_SocketIdType',0,6,50,16
	.word	197
	.byte	8,4
	.word	281
	.byte	9,0,0,10,6,52,9,4,11
	.byte	'Addr',0
	.word	608
	.byte	4,2,35,0,0,4
	.byte	'TcpIp_IpAddressType',0,6,55,3
	.word	617
	.byte	4
	.byte	'TcpIp_DomainType',0,6,61,16
	.word	244
	.byte	10,6,68,9,8,11
	.byte	'Domain',0
	.word	244
	.byte	2,2,35,0,11
	.byte	'Port',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'Addr',0
	.word	608
	.byte	4,2,35,4,0,4
	.byte	'TcpIp_SockAddrInetType',0,6,73,3
	.word	690
	.byte	4
	.byte	'TcpIp_AddressType',0,7,128,1,15
	.word	197
	.byte	4
	.byte	'TcpIp_CtrlIdType',0,7,142,1,15
	.word	197
	.byte	4
	.byte	'TcpIp_IpAddrStateType',0,7,144,1,15
	.word	197
	.byte	4
	.byte	'TcpIp_LocalAddrAssignmentConfigType',0,7,149,1,15
	.word	197
	.byte	4
	.byte	'TcpIp_StaticAddrIdType',0,7,151,1,15
	.word	197
	.byte	10,7,152,1,9,12,11
	.byte	'State',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'Netmask',0
	.word	197
	.byte	1,2,35,1,11
	.byte	'Domain',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'IpAddr',0
	.word	617
	.byte	4,2,35,4,11
	.byte	'DefaultRouter',0
	.word	617
	.byte	4,2,35,8,0,4
	.byte	'TcpIp_StaticIpAddrType',0,7,162,1,3
	.word	932
	.byte	4
	.byte	'TcpIp_LocalAddrIdType',0,7,173,1,15
	.word	197
	.byte	8,3
	.word	197
	.byte	9,2,0,10,7,231,1,9,8,11
	.byte	'CtrlId',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'Address',0
	.word	197
	.byte	1,2,35,1,11
	.byte	'Domain',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'StaticAddrId',0
	.word	197
	.byte	1,2,35,4,11
	.byte	'Assignments',0
	.word	1089
	.byte	3,2,35,5,0,4
	.byte	'TcpIp_LocalAddrConfigType',0,7,243,1,3
	.word	1098
	.byte	10,7,245,1,9,4,11
	.byte	'ArpConfigId',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'DHCPConfigId',0
	.word	197
	.byte	1,2,35,1,11
	.byte	'AutoIpInitTimeout',0
	.word	244
	.byte	2,2,35,2,0,4
	.byte	'TcpIp_IpV4CtrlConfigType',0,7,130,2,3
	.word	1232
	.byte	10,7,133,2,9,8,11
	.byte	'CtrlIdx',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'FramePrio',0
	.word	197
	.byte	1,2,35,1,11
	.byte	'UnicastAddrId',0
	.word	197
	.byte	1,2,35,2,11
	.byte	'UnicastAddrLimit',0
	.word	197
	.byte	1,2,35,3,11
	.byte	'MulticastAddrId',0
	.word	197
	.byte	1,2,35,4,11
	.byte	'LocalAddrLimit',0
	.word	197
	.byte	1,2,35,5,11
	.byte	'IpV4CtrlId',0
	.word	197
	.byte	1,2,35,6,11
	.byte	'IpV6CtrlId',0
	.word	197
	.byte	1,2,35,7,0,4
	.byte	'TcpIp_NetIfCtrlConfigType',0,7,148,2,3
	.word	1343
	.byte	4
	.byte	'SoAd_RoutingGroupIdType',0,8,43,15
	.word	197
	.byte	4
	.byte	'SoAd_SoConIdType',0,8,44,15
	.word	197
	.byte	4
	.byte	'SoAd_SoConGroupIdType',0,8,45,15
	.word	197
	.byte	4
	.byte	'SoAd_PduRouteIdType',0,8,46,15
	.word	197
	.byte	4
	.byte	'SoAd_PduRouteDestIdType',0,8,47,15
	.word	197
	.byte	4
	.byte	'SoAd_SocketRouteIdType',0,8,48,15
	.word	197
	.byte	4
	.byte	'SoAd_IfTxUnconfirmedType',0,8,49,16
	.word	244
	.byte	4
	.byte	'SoAd_IfTxTimerType',0,8,51,16
	.word	244
	.byte	8,1
	.word	197
	.byte	9,0,0,10,8,53,9,2,11
	.byte	'Mask',0
	.word	1797
	.byte	1,2,35,0,11
	.byte	'RoutingState',0
	.word	1797
	.byte	1,2,35,1,0,4
	.byte	'SoAd_RoutingGroupCtrlType',0,8,57,3
	.word	1806
	.byte	6,8,63,9,1,7
	.byte	'SOAD_UL_DOIP',0,0,7
	.byte	'SOAD_UL_UDPNM',0,1,7
	.byte	'SOAD_UL_PDUR',0,2,7
	.byte	'SOAD_UL_XCP',0,3,7
	.byte	'SOAD_UL_MAX',0,4,0,4
	.byte	'SoAd_ULIndexType',0,8,71,3
	.word	1882
	.byte	4
	.byte	'SoAd_RemoteAddressType',0,9,113,32
	.word	690
	.byte	6,9,115,9,1,7
	.byte	'SOAD_SOCON_UNINIT',0,0,7
	.byte	'SOAD_SOCON_OFFLINE',0,1,7
	.byte	'SOAD_SOCON_RECONN',0,2,7
	.byte	'SOAD_SOCON_ONLINE',0,3,0,4
	.byte	'SoAd_SoConModeType',0,9,121,3
	.word	2018
	.byte	12
	.word	197
	.byte	3
	.word	2132
	.byte	12
	.word	197
	.byte	3
	.word	2142
	.byte	12
	.word	197
	.byte	3
	.word	2152
	.byte	12
	.word	1882
	.byte	3
	.word	2162
	.byte	10,9,129,1,9,36,11
	.byte	'IfBufferLength',0
	.word	244
	.byte	2,2,35,0,11
	.byte	'IfBufferOffset',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'TpBufferLength',0
	.word	244
	.byte	2,2,35,4,11
	.byte	'TpBufferOffset',0
	.word	244
	.byte	2,2,35,6,11
	.byte	'PduRouteNum',0
	.word	197
	.byte	1,2,35,8,11
	.byte	'SocketRouteNum',0
	.word	197
	.byte	1,2,35,9,11
	.byte	'PduRouteDestNum',0
	.word	197
	.byte	1,2,35,10,11
	.byte	'RemoteAddrState',0
	.word	197
	.byte	1,2,35,11,11
	.byte	'RemoteAddr',0
	.word	690
	.byte	8,2,35,12,11
	.byte	'PduRouteDestList',0
	.word	2137
	.byte	4,2,35,20,11
	.byte	'PduRouteList',0
	.word	2147
	.byte	4,2,35,24,11
	.byte	'SocketRouteList',0
	.word	2157
	.byte	4,2,35,28,11
	.byte	'SoConModeChgList',0
	.word	2167
	.byte	4,2,35,32,0,4
	.byte	'SoAd_SocketConnectionType',0,9,146,1,3
	.word	2172
	.byte	10,9,148,1,9,16,11
	.byte	'CtrlFlag',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'KeepAliveProbesMax',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'KeepAliveInterval',0
	.word	281
	.byte	4,2,35,4,11
	.byte	'KeepAliveTime',0
	.word	281
	.byte	4,2,35,8,11
	.byte	'TxQuota',0
	.word	281
	.byte	4,2,35,12,0,4
	.byte	'SoAd_TcpProtocolType',0,9,155,1,3
	.word	2524
	.byte	10,9,157,1,9,12,11
	.byte	'CtrlFlag',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'nPduTxBufferMin',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'TriggerTimeout',0
	.word	244
	.byte	2,2,35,4,11
	.byte	'AliveSupervisionTimeout',0
	.word	281
	.byte	4,2,35,6,0,4
	.byte	'SoAd_UdpProtocolType',0,9,163,1,3
	.word	2674
	.byte	12
	.word	2524
	.byte	3
	.word	2811
	.byte	12
	.word	2674
	.byte	3
	.word	2821
	.byte	10,9,165,1,9,24,11
	.byte	'GroupId',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'CtrlFlag',0
	.word	197
	.byte	1,2,35,1,11
	.byte	'FramePriority',0
	.word	197
	.byte	1,2,35,2,11
	.byte	'SoConNum',0
	.word	197
	.byte	1,2,35,3,11
	.byte	'SoConId',0
	.word	197
	.byte	1,2,35,4,11
	.byte	'IpAddrAssignChgNum',0
	.word	197
	.byte	1,2,35,5,11
	.byte	'LocalAddrId',0
	.word	197
	.byte	1,2,35,6,11
	.byte	'LocalPort',0
	.word	244
	.byte	2,2,35,8,11
	.byte	'IpAddrAssignChgList',0
	.word	2167
	.byte	4,2,35,12,11
	.byte	'TcpProtocolPtr',0
	.word	2816
	.byte	4,2,35,16,11
	.byte	'UdpProtocolPtr',0
	.word	2826
	.byte	4,2,35,20,0,4
	.byte	'SoAd_SocketConnectionGroupType',0,9,178,1,3
	.word	2831
	.byte	12
	.word	197
	.byte	3
	.word	3116
	.byte	10,9,180,1,9,12,11
	.byte	'CtrlFlag',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'PduRouteDestNum',0
	.word	197
	.byte	1,2,35,1,11
	.byte	'SocketRouteDestNum',0
	.word	197
	.byte	1,2,35,2,11
	.byte	'PduRouteDestList',0
	.word	3121
	.byte	4,2,35,4,11
	.byte	'SocketRouteDestList',0
	.word	3121
	.byte	4,2,35,8,0,4
	.byte	'SoAd_RoutingGroupType',0,9,187,1,3
	.word	3126
	.byte	10,9,189,1,9,6,11
	.byte	'ULType',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'ULIndex',0
	.word	1882
	.byte	1,2,35,1,11
	.byte	'CtrlFlag',0
	.word	197
	.byte	1,2,35,2,11
	.byte	'RouteDestNum',0
	.word	197
	.byte	1,2,35,3,11
	.byte	'RouteDestId',0
	.word	197
	.byte	1,2,35,4,11
	.byte	'TxPduId',0
	.word	197
	.byte	1,2,35,5,0,4
	.byte	'SoAd_PduRouteType',0,9,204,1,3
	.word	3290
	.byte	3
	.word	1806
	.byte	10,9,206,1,9,20,11
	.byte	'TxPduHeaderId',0
	.word	281
	.byte	4,2,35,0,11
	.byte	'SoConNum',0
	.word	197
	.byte	1,2,35,4,11
	.byte	'SoConId',0
	.word	197
	.byte	1,2,35,5,11
	.byte	'PduRouteId',0
	.word	197
	.byte	1,2,35,6,11
	.byte	'UdpTriggerMode',0
	.word	197
	.byte	1,2,35,7,11
	.byte	'UdpTriggerTimeout',0
	.word	244
	.byte	2,2,35,8,11
	.byte	'RoutingCtrlList',0
	.word	3435
	.byte	4,2,35,12,11
	.byte	'IfTriggerList',0
	.word	474
	.byte	4,2,35,16,0,4
	.byte	'SoAd_PduRouteDestType',0,9,217,1,3
	.word	3440
	.byte	10,9,219,1,9,16,11
	.byte	'RxPduHeaderId',0
	.word	281
	.byte	4,2,35,0,11
	.byte	'ULType',0
	.word	197
	.byte	1,2,35,4,11
	.byte	'ULIndex',0
	.word	1882
	.byte	1,2,35,5,11
	.byte	'SoConNum',0
	.word	197
	.byte	1,2,35,6,11
	.byte	'SoConId',0
	.word	197
	.byte	1,2,35,7,11
	.byte	'RxPduId',0
	.word	197
	.byte	1,2,35,8,11
	.byte	'RoutingCtrlList',0
	.word	3435
	.byte	4,2,35,12,0,4
	.byte	'SoAd_SocketRouteType',0,9,236,1,3
	.word	3655
	.byte	12
	.word	3440
	.byte	3
	.word	3825
	.byte	10,9,155,2,9,24,11
	.byte	'State',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'Timer',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'BufferLength',0
	.word	244
	.byte	2,2,35,4,11
	.byte	'BufferOffset',0
	.word	244
	.byte	2,2,35,6,11
	.byte	'UdpTxBuffer',0
	.word	474
	.byte	4,2,35,8,11
	.byte	'TotalTxLength',0
	.word	244
	.byte	2,2,35,12,11
	.byte	'UsedTxLength',0
	.word	244
	.byte	2,2,35,14,11
	.byte	'IfTxDataBuffer',0
	.word	3121
	.byte	4,2,35,16,11
	.byte	'PduRouteDestPtr',0
	.word	3830
	.byte	4,2,35,20,0,4
	.byte	'SoAd_TxSessionType',0,9,177,2,3
	.word	3835
	.byte	12
	.word	3655
	.byte	3
	.word	4059
	.byte	10,9,180,2,9,8,11
	.byte	'PduLength',0
	.word	244
	.byte	2,2,35,0,11
	.byte	'RemainLength',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'SocketRoutePtr',0
	.word	4064
	.byte	4,2,35,4,0,4
	.byte	'SoAd_RxPduInfoType',0,9,185,2,3
	.word	4069
	.byte	10,9,187,2,9,12,11
	.byte	'TotalLength',0
	.word	244
	.byte	2,2,35,0,11
	.byte	'In',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'Out',0
	.word	244
	.byte	2,2,35,4,11
	.byte	'BufferPtr',0
	.word	474
	.byte	4,2,35,8,0,4
	.byte	'SoAd_RxFifoType',0,9,193,2,3
	.word	4169
	.byte	10,9,195,2,9,8,11
	.byte	'TotalLength',0
	.word	244
	.byte	2,2,35,0,11
	.byte	'UsedLength',0
	.word	244
	.byte	2,2,35,2,11
	.byte	'BufferPtr',0
	.word	474
	.byte	4,2,35,4,0,4
	.byte	'SoAd_RxBufferType',0,9,200,2,3
	.word	4266
	.byte	8,8
	.word	197
	.byte	9,7,0,10,9,202,2,9,48,11
	.byte	'State',0
	.word	197
	.byte	1,2,35,0,11
	.byte	'ValidHeaderLen',0
	.word	197
	.byte	1,2,35,1,11
	.byte	'PduHeader',0
	.word	4360
	.byte	8,2,35,2,11
	.byte	'RxPduInfo',0
	.word	4069
	.byte	8,2,35,12,11
	.byte	'ProcessPduInfo',0
	.word	4069
	.byte	8,2,35,20,11
	.byte	'IfBuffer',0
	.word	4266
	.byte	8,2,35,28,11
	.byte	'TpBuffer',0
	.word	4169
	.byte	12,2,35,36,0,4
	.byte	'SoAd_RxSessionType',0,9,216,2,3
	.word	4369
	.byte	4
	.byte	'u8_t',0,10,61,25
	.word	197
	.byte	5
	.byte	'char',0,1,6,4
	.byte	's8_t',0,10,62,25
	.word	4554
	.byte	4
	.byte	'u16_t',0,10,63,25
	.word	244
	.byte	4
	.byte	'u32_t',0,10,65,25
	.word	281
	.byte	4
	.byte	'err_t',0,11,96,14
	.word	4554
	.byte	13
	.byte	'ip4_addr',0,12,51,8,4,11
	.byte	'addr',0
	.word	281
	.byte	4,2,35,0,0,4
	.byte	'ip4_addr_t',0,12,57,25
	.word	4617
	.byte	4
	.byte	'ip_addr_t',0,13,142,2,20
	.word	4617
	.byte	14
	.byte	'void',0,3
	.word	4684
	.byte	13
	.byte	'pbuf',0,14,186,1,8,16,11
	.byte	'next',0
	.word	.L6-.L3
	.byte	4,2,35,0,11
	.byte	'payload',0
	.word	4690
	.byte	4,2,35,4,11
	.byte	'tot_len',0
	.word	244
	.byte	2,2,35,8,11
	.byte	'len',0
	.word	244
	.byte	2,2,35,10,11
	.byte	'type_internal',0
	.word	197
	.byte	1,2,35,12,11
	.byte	'flags',0
	.word	197
	.byte	1,2,35,13,11
	.byte	'ref',0
	.word	197
	.byte	1,2,35,14,11
	.byte	'if_idx',0
	.word	197
	.byte	1,2,35,15,0
.L6:
	.byte	3
	.word	4695
	.byte	12
	.word	4617
	.byte	3
	.word	4840
	.byte	15
	.word	4554
	.byte	1,1,16
	.word	.L7-.L3
	.byte	16
	.word	4835
	.byte	16
	.word	4845
	.byte	0,3
	.word	4850
	.byte	4
	.byte	'netif_output_fn',0,15,189,1,17
	.word	4873
	.byte	15
	.word	4554
	.byte	1,1,16
	.word	.L7-.L3
	.byte	16
	.word	4835
	.byte	0,3
	.word	4903
	.byte	4
	.byte	'netif_linkoutput_fn',0,15,212,1,17
	.word	4921
	.byte	17,1,1,16
	.word	.L7-.L3
	.byte	0,3
	.word	4955
	.byte	4
	.byte	'netif_status_callback_fn',0,15,214,1,16
	.word	4964
	.byte	8,6
	.word	197
	.byte	9,5,0,5
	.byte	'char',0,1,6,8,2
	.word	5012
	.byte	9,1,0,13
	.byte	'netif',0,15,132,2,8,52,11
	.byte	'next',0
	.word	.L7-.L3
	.byte	4,2,35,0,11
	.byte	'ip_addr',0
	.word	4617
	.byte	4,2,35,4,11
	.byte	'netmask',0
	.word	4617
	.byte	4,2,35,8,11
	.byte	'gw',0
	.word	4617
	.byte	4,2,35,12,11
	.byte	'input',0
	.word	.L8-.L3
	.byte	4,2,35,16,11
	.byte	'output',0
	.word	4878
	.byte	4,2,35,20,11
	.byte	'linkoutput',0
	.word	4926
	.byte	4,2,35,24,11
	.byte	'status_callback',0
	.word	4969
	.byte	4,2,35,28,11
	.byte	'state',0
	.word	4690
	.byte	4,2,35,32,11
	.byte	'mtu',0
	.word	244
	.byte	2,2,35,36,11
	.byte	'hwaddr',0
	.word	5003
	.byte	6,2,35,38,11
	.byte	'hwaddr_len',0
	.word	197
	.byte	1,2,35,44,11
	.byte	'flags',0
	.word	197
	.byte	1,2,35,45,11
	.byte	'name',0
	.word	5020
	.byte	2,2,35,46,11
	.byte	'num',0
	.word	197
	.byte	1,2,35,48,11
	.byte	'rs_count',0
	.word	197
	.byte	1,2,35,49,0
.L7:
	.byte	3
	.word	5029
	.byte	15
	.word	4554
	.byte	1,1,16
	.word	4835
	.byte	16
	.word	5302
	.byte	0,3
	.word	5307
.L8:
	.byte	4
	.byte	'netif_input_fn',0,15,178,1,17
	.word	5325
	.byte	3
	.word	5307
	.byte	3
	.word	4850
	.byte	3
	.word	4903
	.byte	3
	.word	4955
	.byte	13
	.byte	'ip4_addr_packed',0,16,53,8,4,11
	.byte	'addr',0
	.word	281
	.byte	4,2,35,0,0,4
	.byte	'ip4_addr_p_t',0,16,61,32
	.word	5374
	.byte	0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L4:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,21,0,54,15,0,0,3,15,0,73,19,0,0,4,22,0,3,8,58,15,59,15
	.byte	57,15,73,19,0,0,5,36,0,3,8,11,15,62,15,0,0,6,4,1,58,15,59,15,57,15,11,15,0,0,7,40,0,3,8,28,13,0,0,8,1
	.byte	1,11,15,73,19,0,0,9,33,0,47,15,0,0,10,19,1,58,15,59,15,57,15,11,15,0,0,11,13,0,3,8,73,19,11,15,56,9,0
	.byte	0,12,38,0,73,19,0,0,13,19,1,3,8,58,15,59,15,57,15,11,15,0,0,14,59,0,3,8,0,0,15,21,1,73,19,54,15,39,12
	.byte	0,0,16,5,0,73,19,0,0,17,21,1,54,15,39,12,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L5:
	.word	.L10-.L9
.L9:
	.half	3
	.word	.L12-.L11
.L11:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Platform',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\Config',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\Mcal\\Infra_Prod\\Autosar_Srv',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\SoAd',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\arch',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip',0
	.byte	'F:\\LC_SWC_Projiectend\\TC397_PROJECT_NEW\\TC397_DemoProj\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\include\\lwip\\prot',0
	.byte	0
	.byte	'..\\EAS\\BSW\\TcpIp\\lwip-2.1.2\\core\\ipv6\\ip6_frag.c',0,0,0,0
	.byte	'Platform_Types.h',0,1,0,0
	.byte	'Std_Types.h',0,1,0,0
	.byte	'ComStack_Types_Cfg.h',0,2,0,0
	.byte	'ComStack_Types.h',0,3,0,0
	.byte	'TcpIp_GeneratedTypes.h',0,2,0,0
	.byte	'TcpIp_Types.h',0,4,0,0
	.byte	'SoAd_GeneratedTypes.h',0,2,0,0
	.byte	'SoAd_Types.h',0,5,0,0
	.byte	'cc.h',0,6,0,0
	.byte	'err.h',0,7,0,0
	.byte	'ip4_addr.h',0,7,0,0
	.byte	'ip_addr.h',0,7,0,0
	.byte	'pbuf.h',0,7,0,0
	.byte	'netif.h',0,7,0,0
	.byte	'ip4.h',0,8,0,0,0
.L12:
.L10:

; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     1  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     2   * @file
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     3   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     4   * IPv6 fragmentation and reassembly.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     5   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     6  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     7  /*
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     8   * Copyright (c) 2010 Inico Technologies Ltd.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	     9   * All rights reserved.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    10   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    11   * Redistribution and use in source and binary forms, with or without modification,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    12   * are permitted provided that the following conditions are met:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    13   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    14   * 1. Redistributions of source code must retain the above copyright notice,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    15   *    this list of conditions and the following disclaimer.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    16   * 2. Redistributions in binary form must reproduce the above copyright notice,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    17   *    this list of conditions and the following disclaimer in the documentation
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    18   *    and/or other materials provided with the distribution.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    19   * 3. The name of the author may not be used to endorse or promote products
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    20   *    derived from this software without specific prior written permission.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    21   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    22   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    23   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    24   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    25   * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    26   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    27   * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    28   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    29   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    30   * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    31   * OF SUCH DAMAGE.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    32   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    33   * This file is part of the lwIP TCP/IP stack.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    34   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    35   * Author: Ivan Delamer <delamer@inicotech.com>
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    36   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    37   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    38   * Please coordinate changes and requests with Ivan Delamer
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    39   * <delamer@inicotech.com>
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    40   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    41  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    42  #include "lwip/opt.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    43  #include "lwip/ip6_frag.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    44  #include "lwip/ip6.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    45  #include "lwip/icmp6.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    46  #include "lwip/nd6.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    47  #include "lwip/ip.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    48  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    49  #include "lwip/pbuf.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    50  #include "lwip/memp.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    51  #include "lwip/stats.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    52  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    53  #include <string.h>
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    54  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    55  #if LWIP_IPV6 && LWIP_IPV6_REASS  /* don't build if not configured for use in lwipopts.h */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    56  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    57  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    58  /** Setting this to 0, you can turn off checking the fragments for overlapping
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    59   * regions. The code gets a little smaller. Only use this if you know that
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    60   * overlapping won't occur on your network! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    61  #ifndef IP_REASS_CHECK_OVERLAP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    62  #define IP_REASS_CHECK_OVERLAP 1
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    63  #endif /* IP_REASS_CHECK_OVERLAP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    64  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    65  /** Set to 0 to prevent freeing the oldest datagram when the reassembly buffer is
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    66   * full (IP_REASS_MAX_PBUFS pbufs are enqueued). The code gets a little smaller.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    67   * Datagrams will be freed by timeout only. Especially useful when MEMP_NUM_REASSDATA
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    68   * is set to 1, so one datagram can be reassembled at a time, only. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    69  #ifndef IP_REASS_FREE_OLDEST
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    70  #define IP_REASS_FREE_OLDEST 1
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    71  #endif /* IP_REASS_FREE_OLDEST */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    72  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    73  #if IPV6_FRAG_COPYHEADER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    74  /* The number of bytes we need to "borrow" from (i.e., overwrite in) the header
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    75   * that precedes the fragment header for reassembly pruposes. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    76  #define IPV6_FRAG_REQROOM ((s16_t)(sizeof(struct ip6_reass_helper) - IP6_FRAG_HLEN))
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    77  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    78  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    79  #define IP_REASS_FLAG_LASTFRAG 0x01
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    80  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    81  /** This is a helper struct which holds the starting
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    82   * offset and the ending offset of this fragment to
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    83   * easily chain the fragments.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    84   * It has the same packing requirements as the IPv6 header, since it replaces
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    85   * the Fragment Header in memory in incoming fragments to keep
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    86   * track of the various fragments.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    87   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    88  #ifdef PACK_STRUCT_USE_INCLUDES
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    89  #  include "arch/bpstruct.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    90  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    91  PACK_STRUCT_BEGIN
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    92  struct ip6_reass_helper {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    93    PACK_STRUCT_FIELD(struct pbuf *next_pbuf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    94    PACK_STRUCT_FIELD(u16_t start);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    95    PACK_STRUCT_FIELD(u16_t end);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    96  } PACK_STRUCT_STRUCT;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    97  PACK_STRUCT_END
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    98  #ifdef PACK_STRUCT_USE_INCLUDES
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	    99  #  include "arch/epstruct.h"
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   100  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   101  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   102  /* static variables */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   103  static struct ip6_reassdata *reassdatagrams;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   104  static u16_t ip6_reass_pbufcount;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   105  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   106  /* Forward declarations. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   107  static void ip6_reass_free_complete_datagram(struct ip6_reassdata *ipr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   108  #if IP_REASS_FREE_OLDEST
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   109  static void ip6_reass_remove_oldest_datagram(struct ip6_reassdata *ipr, int pbufs_needed);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   110  #endif /* IP_REASS_FREE_OLDEST */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   111  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   112  void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   113  ip6_reass_tmr(void)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   114  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   115    struct ip6_reassdata *r, *tmp;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   116  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   117  #if !IPV6_FRAG_COPYHEADER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   118    LWIP_ASSERT("sizeof(struct ip6_reass_helper) <= IP6_FRAG_HLEN, set IPV6_FRAG_COPYHEADER to 1",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   119      sizeof(struct ip6_reass_helper) <= IP6_FRAG_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   120  #endif /* !IPV6_FRAG_COPYHEADER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   121  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   122    r = reassdatagrams;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   123    while (r != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   124      /* Decrement the timer. Once it reaches 0,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   125       * clean up the incomplete fragment assembly */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   126      if (r->timer > 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   127        r->timer--;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   128        r = r->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   129      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   130        /* reassembly timed out */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   131        tmp = r;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   132        /* get the next pointer before freeing */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   133        r = r->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   134        /* free the helper struct and all enqueued pbufs */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   135        ip6_reass_free_complete_datagram(tmp);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   136       }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   137     }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   138  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   139  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   140  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   141   * Free a datagram (struct ip6_reassdata) and all its pbufs.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   142   * Updates the total count of enqueued pbufs (ip6_reass_pbufcount),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   143   * sends an ICMP time exceeded packet.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   144   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   145   * @param ipr datagram to free
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   146   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   147  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   148  ip6_reass_free_complete_datagram(struct ip6_reassdata *ipr)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   149  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   150    struct ip6_reassdata *prev;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   151    u16_t pbufs_freed = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   152    u16_t clen;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   153    struct pbuf *p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   154    struct ip6_reass_helper *iprh;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   155  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   156  #if LWIP_ICMP6
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   157    iprh = (struct ip6_reass_helper *)ipr->p->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   158    if (iprh->start == 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   159      /* The first fragment was received, send ICMP time exceeded. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   160      /* First, de-queue the first pbuf from r->p. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   161      p = ipr->p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   162      ipr->p = iprh->next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   163      /* Restore the part that we've overwritten with our helper structure, or we
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   164       * might send garbage (and disclose a pointer) in the ICMPv6 reply. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   165      MEMCPY(p->payload, ipr->orig_hdr, sizeof(iprh));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   166      /* Then, move back to the original ipv6 header (we are now pointing to Fragment header).
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   167         This cannot fail since we already checked when receiving this fragment. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   168      if (pbuf_header_force(p, (s16_t)((u8_t*)p->payload - (u8_t*)ipr->iphdr))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   169        LWIP_ASSERT("ip6_reass_free: moving p->payload to ip6 header failed\n", 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   170      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   171      else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   172        /* Reconstruct the zoned source and destination addresses, so that we do
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   173         * not end up sending the ICMP response over the wrong link. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   174        ip6_addr_t src_addr, dest_addr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   175        ip6_addr_copy_from_packed(src_addr, IPV6_FRAG_SRC(ipr));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   176        ip6_addr_set_zone(&src_addr, ipr->src_zone);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   177        ip6_addr_copy_from_packed(dest_addr, IPV6_FRAG_DEST(ipr));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   178        ip6_addr_set_zone(&dest_addr, ipr->dest_zone);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   179        /* Send the actual ICMP response. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   180        icmp6_time_exceeded_with_addrs(p, ICMP6_TE_FRAG, &src_addr, &dest_addr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   181      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   182      clen = pbuf_clen(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   183      LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   184      pbufs_freed = (u16_t)(pbufs_freed + clen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   185      pbuf_free(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   186    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   187  #endif /* LWIP_ICMP6 */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   188  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   189    /* First, free all received pbufs.  The individual pbufs need to be released
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   190       separately as they have not yet been chained */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   191    p = ipr->p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   192    while (p != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   193      struct pbuf *pcur;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   194      iprh = (struct ip6_reass_helper *)p->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   195      pcur = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   196      /* get the next pointer before freeing */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   197      p = iprh->next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   198      clen = pbuf_clen(pcur);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   199      LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   200      pbufs_freed = (u16_t)(pbufs_freed + clen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   201      pbuf_free(pcur);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   202    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   203  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   204    /* Then, unchain the struct ip6_reassdata from the list and free it. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   205    if (ipr == reassdatagrams) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   206      reassdatagrams = ipr->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   207    } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   208      prev = reassdatagrams;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   209      while (prev != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   210        if (prev->next == ipr) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   211          break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   212        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   213        prev = prev->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   214      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   215      if (prev != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   216        prev->next = ipr->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   217      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   218    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   219    memp_free(MEMP_IP6_REASSDATA, ipr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   220  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   221    /* Finally, update number of pbufs in reassembly queue */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   222    LWIP_ASSERT("ip_reass_pbufcount >= clen", ip6_reass_pbufcount >= pbufs_freed);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   223    ip6_reass_pbufcount = (u16_t)(ip6_reass_pbufcount - pbufs_freed);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   224  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   225  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   226  #if IP_REASS_FREE_OLDEST
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   227  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   228   * Free the oldest datagram to make room for enqueueing new fragments.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   229   * The datagram ipr is not freed!
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   230   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   231   * @param ipr ip6_reassdata for the current fragment
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   232   * @param pbufs_needed number of pbufs needed to enqueue
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   233   *        (used for freeing other datagrams if not enough space)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   234   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   235  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   236  ip6_reass_remove_oldest_datagram(struct ip6_reassdata *ipr, int pbufs_needed)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   237  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   238    struct ip6_reassdata *r, *oldest;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   239  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   240    /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   241     * but don't free the current datagram! */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   242    do {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   243      r = oldest = reassdatagrams;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   244      while (r != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   245        if (r != ipr) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   246          if (r->timer <= oldest->timer) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   247            /* older than the previous oldest */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   248            oldest = r;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   249          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   250        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   251        r = r->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   252      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   253      if (oldest == ipr) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   254        /* nothing to free, ipr is the only element on the list */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   255        return;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   256      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   257      if (oldest != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   258        ip6_reass_free_complete_datagram(oldest);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   259      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   260    } while (((ip6_reass_pbufcount + pbufs_needed) > IP_REASS_MAX_PBUFS) && (reassdatagrams != NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   261  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   262  #endif /* IP_REASS_FREE_OLDEST */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   263  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   264  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   265   * Reassembles incoming IPv6 fragments into an IPv6 datagram.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   266   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   267   * @param p points to the IPv6 Fragment Header
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   268   * @return NULL if reassembly is incomplete, pbuf pointing to
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   269   *         IPv6 Header if reassembly is complete
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   270   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   271  struct pbuf *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   272  ip6_reass(struct pbuf *p)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   273  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   274    struct ip6_reassdata *ipr, *ipr_prev;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   275    struct ip6_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   276    struct ip6_frag_hdr *frag_hdr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   277    u16_t offset, len, start, end;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   278    ptrdiff_t hdrdiff;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   279    u16_t clen;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   280    u8_t valid = 1;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   281    struct pbuf *q, *next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   282  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   283    IP6_FRAG_STATS_INC(ip6_frag.recv);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   284  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   285    /* ip6_frag_hdr must be in the first pbuf, not chained. Checked by caller. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   286    LWIP_ASSERT("IPv6 fragment header does not fit in first pbuf",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   287      p->len >= sizeof(struct ip6_frag_hdr));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   288  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   289    frag_hdr = (struct ip6_frag_hdr *) p->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   290  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   291    clen = pbuf_clen(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   292  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   293    offset = lwip_ntohs(frag_hdr->_fragment_offset);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   294  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   295    /* Calculate fragment length from IPv6 payload length.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   296     * Adjust for headers before Fragment Header.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   297     * And finally adjust by Fragment Header length. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   298    len = lwip_ntohs(ip6_current_header()->_plen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   299    hdrdiff = (u8_t*)p->payload - (const u8_t*)ip6_current_header();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   300    LWIP_ASSERT("not a valid pbuf (ip6_input check missing?)", hdrdiff <= 0xFFFF);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   301    LWIP_ASSERT("not a valid pbuf (ip6_input check missing?)", hdrdiff >= IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   302    hdrdiff -= IP6_HLEN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   303    hdrdiff += IP6_FRAG_HLEN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   304    if (hdrdiff > len) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   305      IP6_FRAG_STATS_INC(ip6_frag.proterr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   306      goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   307    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   308    len = (u16_t)(len - hdrdiff);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   309    start = (offset & IP6_FRAG_OFFSET_MASK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   310    if (start > (0xFFFF - len)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   311      /* u16_t overflow, cannot handle this */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   312      IP6_FRAG_STATS_INC(ip6_frag.proterr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   313      goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   314    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   315  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   316    /* Look for the datagram the fragment belongs to in the current datagram queue,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   317     * remembering the previous in the queue for later dequeueing. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   318    for (ipr = reassdatagrams, ipr_prev = NULL; ipr != NULL; ipr = ipr->next) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   319      /* Check if the incoming fragment matches the one currently present
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   320         in the reassembly buffer. If so, we proceed with copying the
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   321         fragment into the buffer. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   322      if ((frag_hdr->_identification == ipr->identification) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   323          ip6_addr_cmp_packed(ip6_current_src_addr(), &(IPV6_FRAG_SRC(ipr)), ipr->src_zone) &&
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   324          ip6_addr_cmp_packed(ip6_current_dest_addr(), &(IPV6_FRAG_DEST(ipr)), ipr->dest_zone)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   325        IP6_FRAG_STATS_INC(ip6_frag.cachehit);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   326        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   327      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   328      ipr_prev = ipr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   329    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   330  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   331    if (ipr == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   332    /* Enqueue a new datagram into the datagram queue */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   333      ipr = (struct ip6_reassdata *)memp_malloc(MEMP_IP6_REASSDATA);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   334      if (ipr == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   335  #if IP_REASS_FREE_OLDEST
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   336        /* Make room and try again. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   337        ip6_reass_remove_oldest_datagram(ipr, clen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   338        ipr = (struct ip6_reassdata *)memp_malloc(MEMP_IP6_REASSDATA);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   339        if (ipr != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   340          /* re-search ipr_prev since it might have been removed */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   341          for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   342            if (ipr_prev->next == ipr) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   343              break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   344            }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   345          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   346        } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   347  #endif /* IP_REASS_FREE_OLDEST */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   348        {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   349          IP6_FRAG_STATS_INC(ip6_frag.memerr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   350          goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   351        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   352      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   353  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   354      memset(ipr, 0, sizeof(struct ip6_reassdata));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   355      ipr->timer = IPV6_REASS_MAXAGE;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   356  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   357      /* enqueue the new structure to the front of the list */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   358      ipr->next = reassdatagrams;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   359      reassdatagrams = ipr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   360  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   361      /* Use the current IPv6 header for src/dest address reference.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   362       * Eventually, we will replace it when we get the first fragment
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   363       * (it might be this one, in any case, it is done later). */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   364      /* need to use the none-const pointer here: */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   365      ipr->iphdr = ip_data.current_ip6_header;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   366  #if IPV6_FRAG_COPYHEADER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   367      MEMCPY(&ipr->src, &ip6_current_header()->src, sizeof(ipr->src));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   368      MEMCPY(&ipr->dest, &ip6_current_header()->dest, sizeof(ipr->dest));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   369  #endif /* IPV6_FRAG_COPYHEADER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   370  #if LWIP_IPV6_SCOPES
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   371      /* Also store the address zone information.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   372       * @todo It is possible that due to netif destruction and recreation, the
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   373       * stored zones end up resolving to a different interface. In that case, we
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   374       * risk sending a "time exceeded" ICMP response over the wrong link.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   375       * Ideally, netif destruction would clean up matching pending reassembly
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   376       * structures, but custom zone mappings would make that non-trivial. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   377      ipr->src_zone = ip6_addr_zone(ip6_current_src_addr());
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   378      ipr->dest_zone = ip6_addr_zone(ip6_current_dest_addr());
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   379  #endif /* LWIP_IPV6_SCOPES */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   380      /* copy the fragmented packet id. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   381      ipr->identification = frag_hdr->_identification;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   382  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   383      /* copy the nexth field */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   384      ipr->nexth = frag_hdr->_nexth;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   385    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   386  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   387    /* Check if we are allowed to enqueue more datagrams. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   388    if ((ip6_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   389  #if IP_REASS_FREE_OLDEST
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   390      ip6_reass_remove_oldest_datagram(ipr, clen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   391      if ((ip6_reass_pbufcount + clen) <= IP_REASS_MAX_PBUFS) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   392        /* re-search ipr_prev since it might have been removed */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   393        for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   394          if (ipr_prev->next == ipr) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   395            break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   396          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   397        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   398      } else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   399  #endif /* IP_REASS_FREE_OLDEST */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   400      {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   401        /* @todo: send ICMPv6 time exceeded here? */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   402        /* drop this pbuf */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   403        IP6_FRAG_STATS_INC(ip6_frag.memerr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   404        goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   405      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   406    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   407  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   408    /* Overwrite Fragment Header with our own helper struct. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   409  #if IPV6_FRAG_COPYHEADER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   410    if (IPV6_FRAG_REQROOM > 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   411      /* Make room for struct ip6_reass_helper (only required if sizeof(void*) > 4).
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   412         This cannot fail since we already checked when receiving this fragment. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   413      u8_t hdrerr = pbuf_header_force(p, IPV6_FRAG_REQROOM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   414      LWIP_UNUSED_ARG(hdrerr); /* in case of LWIP_NOASSERT */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   415      LWIP_ASSERT("no room for struct ip6_reass_helper", hdrerr == 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   416    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   417  #else /* IPV6_FRAG_COPYHEADER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   418    LWIP_ASSERT("sizeof(struct ip6_reass_helper) <= IP6_FRAG_HLEN, set IPV6_FRAG_COPYHEADER to 1",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   419      sizeof(struct ip6_reass_helper) <= IP6_FRAG_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   420  #endif /* IPV6_FRAG_COPYHEADER */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   421  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   422    /* Prepare the pointer to the helper structure, and its initial values.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   423     * Do not yet write to the structure itself, as we still have to make a
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   424     * backup of the original data, and we should not do that until we know for
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   425     * sure that we are going to add this packet to the list. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   426    iprh = (struct ip6_reass_helper *)p->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   427    next_pbuf = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   428    end = (u16_t)(start + len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   429  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   430    /* find the right place to insert this pbuf */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   431    /* Iterate through until we either get to the end of the list (append),
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   432     * or we find on with a larger offset (insert). */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   433    for (q = ipr->p; q != NULL;) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   434      iprh_tmp = (struct ip6_reass_helper*)q->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   435      if (start < iprh_tmp->start) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   436  #if IP_REASS_CHECK_OVERLAP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   437        if (end > iprh_tmp->start) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   438          /* fragment overlaps with following, throw away */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   439          IP6_FRAG_STATS_INC(ip6_frag.proterr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   440          goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   441        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   442        if (iprh_prev != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   443          if (start < iprh_prev->end) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   444            /* fragment overlaps with previous, throw away */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   445            IP6_FRAG_STATS_INC(ip6_frag.proterr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   446            goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   447          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   448        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   449  #endif /* IP_REASS_CHECK_OVERLAP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   450        /* the new pbuf should be inserted before this */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   451        next_pbuf = q;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   452        if (iprh_prev != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   453          /* not the fragment with the lowest offset */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   454          iprh_prev->next_pbuf = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   455        } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   456          /* fragment with the lowest offset */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   457          ipr->p = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   458        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   459        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   460      } else if (start == iprh_tmp->start) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   461        /* received the same datagram twice: no need to keep the datagram */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   462        goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   463  #if IP_REASS_CHECK_OVERLAP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   464      } else if (start < iprh_tmp->end) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   465        /* overlap: no need to keep the new datagram */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   466        IP6_FRAG_STATS_INC(ip6_frag.proterr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   467        goto nullreturn;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   468  #endif /* IP_REASS_CHECK_OVERLAP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   469      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   470        /* Check if the fragments received so far have no gaps. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   471        if (iprh_prev != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   472          if (iprh_prev->end != iprh_tmp->start) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   473            /* There is a fragment missing between the current
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   474             * and the previous fragment */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   475            valid = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   476          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   477        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   478      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   479      q = iprh_tmp->next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   480      iprh_prev = iprh_tmp;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   481    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   482  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   483    /* If q is NULL, then we made it to the end of the list. Determine what to do now */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   484    if (q == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   485      if (iprh_prev != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   486        /* this is (for now), the fragment with the highest offset:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   487         * chain it to the last fragment */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   488  #if IP_REASS_CHECK_OVERLAP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   489        LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= start);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   490  #endif /* IP_REASS_CHECK_OVERLAP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   491        iprh_prev->next_pbuf = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   492        if (iprh_prev->end != start) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   493          valid = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   494        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   495      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   496  #if IP_REASS_CHECK_OVERLAP
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   497        LWIP_ASSERT("no previous fragment, this must be the first fragment!",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   498          ipr->p == NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   499  #endif /* IP_REASS_CHECK_OVERLAP */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   500        /* this is the first fragment we ever received for this ip datagram */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   501        ipr->p = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   502      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   503    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   504  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   505    /* Track the current number of pbufs current 'in-flight', in order to limit
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   506    the number of fragments that may be enqueued at any one time */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   507    ip6_reass_pbufcount = (u16_t)(ip6_reass_pbufcount + clen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   508  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   509    /* Remember IPv6 header if this is the first fragment. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   510    if (start == 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   511      /* need to use the none-const pointer here: */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   512      ipr->iphdr = ip_data.current_ip6_header;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   513      /* Make a backup of the part of the packet data that we are about to
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   514       * overwrite, so that we can restore the original later. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   515      MEMCPY(ipr->orig_hdr, p->payload, sizeof(*iprh));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   516      /* For IPV6_FRAG_COPYHEADER there is no need to copy src/dst again, as they
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   517       * will be the same as they were. With LWIP_IPV6_SCOPES, the same applies
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   518       * to the source/destination zones. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   519    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   520    /* Only after the backup do we get to fill in the actual helper structure. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   521    iprh->next_pbuf = next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   522    iprh->start = start;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   523    iprh->end = end;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   524  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   525    /* If this is the last fragment, calculate total packet length. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   526    if ((offset & IP6_FRAG_MORE_FLAG) == 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   527      ipr->datagram_len = iprh->end;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   528    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   529  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   530    /* Additional validity tests: we have received first and last fragment. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   531    iprh_tmp = (struct ip6_reass_helper*)ipr->p->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   532    if (iprh_tmp->start != 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   533      valid = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   534    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   535    if (ipr->datagram_len == 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   536      valid = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   537    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   538  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   539    /* Final validity test: no gaps between current and last fragment. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   540    iprh_prev = iprh;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   541    q = iprh->next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   542    while ((q != NULL) && valid) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   543      iprh = (struct ip6_reass_helper*)q->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   544      if (iprh_prev->end != iprh->start) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   545        valid = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   546        break;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   547      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   548      iprh_prev = iprh;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   549      q = iprh->next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   550    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   551  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   552    if (valid) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   553      /* All fragments have been received */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   554      struct ip6_hdr* iphdr_ptr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   555  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   556      /* chain together the pbufs contained within the ip6_reassdata list. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   557      iprh = (struct ip6_reass_helper*) ipr->p->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   558      while (iprh != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   559        next_pbuf = iprh->next_pbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   560        if (next_pbuf != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   561          /* Save next helper struct (will be hidden in next step). */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   562          iprh_tmp = (struct ip6_reass_helper*)next_pbuf->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   563  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   564          /* hide the fragment header for every succeeding fragment */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   565          pbuf_remove_header(next_pbuf, IP6_FRAG_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   566  #if IPV6_FRAG_COPYHEADER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   567          if (IPV6_FRAG_REQROOM > 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   568            /* hide the extra bytes borrowed from ip6_hdr for struct ip6_reass_helper */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   569            u8_t hdrerr = pbuf_remove_header(next_pbuf, IPV6_FRAG_REQROOM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   570            LWIP_UNUSED_ARG(hdrerr); /* in case of LWIP_NOASSERT */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   571            LWIP_ASSERT("no room for struct ip6_reass_helper", hdrerr == 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   572          }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   573  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   574          pbuf_cat(ipr->p, next_pbuf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   575        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   576        else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   577          iprh_tmp = NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   578        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   579  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   580        iprh = iprh_tmp;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   581      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   582  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   583      /* Get the first pbuf. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   584      p = ipr->p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   585  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   586  #if IPV6_FRAG_COPYHEADER
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   587      if (IPV6_FRAG_REQROOM > 0) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   588        u8_t hdrerr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   589        /* Restore (only) the bytes that we overwrote beyond the fragment header.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   590         * Those bytes may belong to either the IPv6 header or an extension
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   591         * header placed before the fragment header. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   592        MEMCPY(p->payload, ipr->orig_hdr, IPV6_FRAG_REQROOM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   593        /* get back room for struct ip6_reass_helper (only required if sizeof(void*) > 4) */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   594        hdrerr = pbuf_remove_header(p, IPV6_FRAG_REQROOM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   595        LWIP_UNUSED_ARG(hdrerr); /* in case of LWIP_NOASSERT */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   596        LWIP_ASSERT("no room for struct ip6_reass_helper", hdrerr == 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   597      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   598  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   599  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   600      /* We need to get rid of the fragment header itself, which is somewhere in
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   601       * the middle of the packet (but still in the first pbuf of the chain).
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   602       * Getting rid of the header is required by RFC 2460 Sec. 4.5 and necessary
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   603       * in order to be able to reassemble packets that are close to full size
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   604       * (i.e., around 65535 bytes). We simply move up all the headers before the
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   605       * fragment header, including the IPv6 header, and adjust the payload start
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   606       * accordingly. This works because all these headers are in the first pbuf
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   607       * of the chain, and because the caller adjusts all its pointers on
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   608       * successful reassembly. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   609      MEMMOVE((u8_t*)ipr->iphdr + sizeof(struct ip6_frag_hdr), ipr->iphdr,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   610        (size_t)((u8_t*)p->payload - (u8_t*)ipr->iphdr));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   611  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   612      /* This is where the IPv6 header is now. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   613      iphdr_ptr = (struct ip6_hdr*)((u8_t*)ipr->iphdr +
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   614        sizeof(struct ip6_frag_hdr));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   615  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   616      /* Adjust datagram length by adding header lengths. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   617      ipr->datagram_len = (u16_t)(ipr->datagram_len + ((u8_t*)p->payload - (u8_t*)iphdr_ptr)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   618                           - IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   619  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   620      /* Set payload length in ip header. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   621      iphdr_ptr->_plen = lwip_htons(ipr->datagram_len);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   622  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   623      /* With the fragment header gone, we now need to adjust the next-header
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   624       * field of whatever header was originally before it. Since the packet made
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   625       * it through the original header processing routines at least up to the
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   626       * fragment header, we do not need any further sanity checks here. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   627      if (IP6H_NEXTH(iphdr_ptr) == IP6_NEXTH_FRAGMENT) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   628        iphdr_ptr->_nexth = ipr->nexth;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   629      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   630        u8_t *ptr = (u8_t *)iphdr_ptr + IP6_HLEN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   631        while (*ptr != IP6_NEXTH_FRAGMENT) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   632          ptr += 8 * (1 + ptr[1]);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   633        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   634        *ptr = ipr->nexth;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   635      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   636  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   637      /* release the resources allocated for the fragment queue entry */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   638      if (reassdatagrams == ipr) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   639        /* it was the first in the list */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   640        reassdatagrams = ipr->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   641      } else {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   642        /* it wasn't the first, so it must have a valid 'prev' */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   643        LWIP_ASSERT("sanity check linked list", ipr_prev != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   644        ipr_prev->next = ipr->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   645      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   646      memp_free(MEMP_IP6_REASSDATA, ipr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   647  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   648      /* adjust the number of pbufs currently queued for reassembly. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   649      clen = pbuf_clen(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   650      LWIP_ASSERT("ip6_reass_pbufcount >= clen", ip6_reass_pbufcount >= clen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   651      ip6_reass_pbufcount = (u16_t)(ip6_reass_pbufcount - clen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   652  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   653      /* Move pbuf back to IPv6 header. This should never fail. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   654      if (pbuf_header_force(p, (s16_t)((u8_t*)p->payload - (u8_t*)iphdr_ptr))) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   655        LWIP_ASSERT("ip6_reass: moving p->payload to ip6 header failed\n", 0);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   656        pbuf_free(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   657        return NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   658      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   659  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   660      /* Return the pbuf chain */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   661      return p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   662    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   663    /* the datagram is not (yet?) reassembled completely */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   664    return NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   665  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   666  nullreturn:
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   667    IP6_FRAG_STATS_INC(ip6_frag.drop);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   668    pbuf_free(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   669    return NULL;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   670  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   671  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   672  #endif /* LWIP_IPV6 && LWIP_IPV6_REASS */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   673  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   674  #if LWIP_IPV6 && LWIP_IPV6_FRAG
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   675  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   676  #if !LWIP_NETIF_TX_SINGLE_PBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   677  /** Allocate a new struct pbuf_custom_ref */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   678  static struct pbuf_custom_ref*
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   679  ip6_frag_alloc_pbuf_custom_ref(void)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   680  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   681    return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   682  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   683  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   684  /** Free a struct pbuf_custom_ref */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   685  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   686  ip6_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   687  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   688    LWIP_ASSERT("p != NULL", p != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   689    memp_free(MEMP_FRAG_PBUF, p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   690  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   691  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   692  /** Free-callback function to free a 'struct pbuf_custom_ref', called by
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   693   * pbuf_free. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   694  static void
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   695  ip6_frag_free_pbuf_custom(struct pbuf *p)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   696  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   697    struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   698    LWIP_ASSERT("pcr != NULL", pcr != NULL);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   699    LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   700    if (pcr->original != NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   701      pbuf_free(pcr->original);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   702    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   703    ip6_frag_free_pbuf_custom_ref(pcr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   704  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   705  #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   706  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   707  /**
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   708   * Fragment an IPv6 datagram if too large for the netif or path MTU.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   709   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   710   * Chop the datagram in MTU sized chunks and send them in order
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   711   * by pointing PBUF_REFs into p
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   712   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   713   * @param p ipv6 packet to send
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   714   * @param netif the netif on which to send
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   715   * @param dest destination ipv6 address to which to send
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   716   *
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   717   * @return ERR_OK if sent successfully, err_t otherwise
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   718   */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   719  err_t
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   720  ip6_frag(struct pbuf *p, struct netif *netif, const ip6_addr_t *dest)
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   721  {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   722    struct ip6_hdr *original_ip6hdr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   723    struct ip6_hdr *ip6hdr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   724    struct ip6_frag_hdr *frag_hdr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   725    struct pbuf *rambuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   726  #if !LWIP_NETIF_TX_SINGLE_PBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   727    struct pbuf *newpbuf;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   728    u16_t newpbuflen = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   729    u16_t left_to_copy;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   730  #endif
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   731    static u32_t identification;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   732    u16_t left, cop;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   733    const u16_t mtu = nd6_get_destination_mtu(dest, netif);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   734    const u16_t nfb = (u16_t)((mtu - (IP6_HLEN + IP6_FRAG_HLEN)) & IP6_FRAG_OFFSET_MASK);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   735    u16_t fragment_offset = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   736    u16_t last;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   737    u16_t poff = IP6_HLEN;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   738  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   739    identification++;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   740  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   741    original_ip6hdr = (struct ip6_hdr *)p->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   742  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   743    /* @todo we assume there are no options in the unfragmentable part (IPv6 header). */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   744    LWIP_ASSERT("p->tot_len >= IP6_HLEN", p->tot_len >= IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   745    left = (u16_t)(p->tot_len - IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   746  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   747    while (left) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   748      last = (left <= nfb);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   749  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   750      /* Fill this fragment */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   751      cop = last ? left : nfb;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   752  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   753  #if LWIP_NETIF_TX_SINGLE_PBUF
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   754      rambuf = pbuf_alloc(PBUF_IP, cop + IP6_FRAG_HLEN, PBUF_RAM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   755      if (rambuf == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   756        IP6_FRAG_STATS_INC(ip6_frag.memerr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   757        return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   758      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   759      LWIP_ASSERT("this needs a pbuf in one piece!",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   760        (rambuf->len == rambuf->tot_len) && (rambuf->next == NULL));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   761      poff += pbuf_copy_partial(p, (u8_t*)rambuf->payload + IP6_FRAG_HLEN, cop, poff);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   762      /* make room for the IP header */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   763      if (pbuf_add_header(rambuf, IP6_HLEN)) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   764        pbuf_free(rambuf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   765        IP6_FRAG_STATS_INC(ip6_frag.memerr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   766        return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   767      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   768      /* fill in the IP header */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   769      SMEMCPY(rambuf->payload, original_ip6hdr, IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   770      ip6hdr = (struct ip6_hdr *)rambuf->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   771      frag_hdr = (struct ip6_frag_hdr *)((u8_t*)rambuf->payload + IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   772  #else
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   773      /* When not using a static buffer, create a chain of pbufs.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   774       * The first will be a PBUF_RAM holding the link, IPv6, and Fragment header.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   775       * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   776       * but limited to the size of an mtu.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   777       */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   778      rambuf = pbuf_alloc(PBUF_LINK, IP6_HLEN + IP6_FRAG_HLEN, PBUF_RAM);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   779      if (rambuf == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   780        IP6_FRAG_STATS_INC(ip6_frag.memerr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   781        return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   782      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   783      LWIP_ASSERT("this needs a pbuf in one piece!",
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   784                  (p->len >= (IP6_HLEN)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   785      SMEMCPY(rambuf->payload, original_ip6hdr, IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   786      ip6hdr = (struct ip6_hdr *)rambuf->payload;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   787      frag_hdr = (struct ip6_frag_hdr *)((u8_t*)rambuf->payload + IP6_HLEN);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   788  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   789      /* Can just adjust p directly for needed offset. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   790      p->payload = (u8_t *)p->payload + poff;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   791      p->len = (u16_t)(p->len - poff);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   792      p->tot_len = (u16_t)(p->tot_len - poff);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   793  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   794      left_to_copy = cop;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   795      while (left_to_copy) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   796        struct pbuf_custom_ref *pcr;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   797        newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   798        /* Is this pbuf already empty? */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   799        if (!newpbuflen) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   800          p = p->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   801          continue;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   802        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   803        pcr = ip6_frag_alloc_pbuf_custom_ref();
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   804        if (pcr == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   805          pbuf_free(rambuf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   806          IP6_FRAG_STATS_INC(ip6_frag.memerr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   807          return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   808        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   809        /* Mirror this pbuf, although we might not need all of it. */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   810        newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   811        if (newpbuf == NULL) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   812          ip6_frag_free_pbuf_custom_ref(pcr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   813          pbuf_free(rambuf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   814          IP6_FRAG_STATS_INC(ip6_frag.memerr);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   815          return ERR_MEM;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   816        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   817        pbuf_ref(p);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   818        pcr->original = p;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   819        pcr->pc.custom_free_function = ip6_frag_free_pbuf_custom;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   820  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   821        /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   822         * so that it is removed when pbuf_dechain is later called on rambuf.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   823         */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   824        pbuf_cat(rambuf, newpbuf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   825        left_to_copy = (u16_t)(left_to_copy - newpbuflen);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   826        if (left_to_copy) {
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   827          p = p->next;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   828        }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   829      }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   830      poff = newpbuflen;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   831  #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   832  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   833      /* Set headers */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   834      frag_hdr->_nexth = original_ip6hdr->_nexth;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   835      frag_hdr->reserved = 0;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   836      frag_hdr->_fragment_offset = lwip_htons((u16_t)((fragment_offset & IP6_FRAG_OFFSET_MASK) | (last ? 0 : IP6_FRAG_MORE_FLAG)));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   837      frag_hdr->_identification = lwip_htonl(identification);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   838  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   839      IP6H_NEXTH_SET(ip6hdr, IP6_NEXTH_FRAGMENT);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   840      IP6H_PLEN_SET(ip6hdr, (u16_t)(cop + IP6_FRAG_HLEN));
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   841  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   842      /* No need for separate header pbuf - we allowed room for it in rambuf
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   843       * when allocated.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   844       */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   845      IP6_FRAG_STATS_INC(ip6_frag.xmit);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   846      netif->output_ip6(netif, rambuf, dest);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   847  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   848      /* Unfortunately we can't reuse rambuf - the hardware may still be
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   849       * using the buffer. Instead we free it (and the ensuing chain) and
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   850       * recreate it next time round the loop. If we're lucky the hardware
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   851       * will have already sent the packet, the free will really free, and
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   852       * there will be zero memory penalty.
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   853       */
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   854  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   855      pbuf_free(rambuf);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   856      left = (u16_t)(left - cop);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   857      fragment_offset = (u16_t)(fragment_offset + cop);
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   858    }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   859    return ERR_OK;
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   860  }
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   861  
; ..\EAS\BSW\TcpIp\lwip-2.1.2\core\ipv6\ip6_frag.c	   862  #endif /* LWIP_IPV6 && LWIP_IPV6_FRAG */

	; Module end
