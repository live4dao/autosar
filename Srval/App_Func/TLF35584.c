/**********************************************************************************************************************
 * \file TLF35584.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "TLF35584.h"

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
tlf35584 g_tlfDevice;

void unlockRegisterTLF35584(void);
void lockRegisterTLF35584(void);
void disableWindowWatchdogTLF35584(tlf35584 *tlfDevice);
void enableWindowWatchdogTLF35584(tlf35584 *tlfDevice);
void disableErrPinMonitorTLF35584(tlf35584 *tlfDevice);
void enableErrPinMonitorTLF35584(tlf35584 *tlfDevice);
void enableVoltageSupplyRails(tlf35584 *tlfDevice);
uint8 getSpiStatusFlagsTLF35584(tlf35584 *tlfDevice);
void clearSpiStatusFlagsTLF35584(tlf35584 *tlfDevice);
uint16 transferDataTLF35584(spiCommandType cmd, tlf35584RegAddr addr, uint8 data);

#define PMIC_SPI_BUFFER_SIZE 1

/*********************************************************************************************************************/
/*----------------------------------------------Function Implementations---------------------------------------------*/
/*********************************************************************************************************************/
void unlockRegisterTLF35584(void)
{
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey1);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey2);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey3);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey4);
}

void lockRegisterTLF35584(void)
{
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey1);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey2);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey3);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey4);
}

void disableWindowWatchdogTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    /* Get the value of RWDCFG0 to check the current window watchdog setting */
    spiFrame.U = transferDataTLF35584(SpiCommand_read, Rwdcfg0RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->WDCFG0.U = spiFrame.B.data;

    if(tlfDevice->WDCFG0.B.WWDEN == WindowWatchdog_enabled)
    {
        tlfDevice->WDCFG0.B.WWDEN = WindowWatchdog_disabled;
        transferDataTLF35584(SpiCommand_write, Wdcfg0RegAddr, tlfDevice->WDCFG0.U);
    }
}

void enableWindowWatchdogTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    /* Get the value of RWDCFG0 to check the current window watchdog setting */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Rwdcfg0RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->RWDCFG0.U = spiFrame.B.data;

    if(tlfDevice->RWDCFG0.B.WWDEN == WindowWatchdog_disabled)
    {
        tlfDevice->WDCFG0.B.WWDEN = WindowWatchdog_enabled;
        transferDataTLF35584(SpiCommand_write, Wdcfg0RegAddr, tlfDevice->WDCFG0.U);
    }
}

void disableErrPinMonitorTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    /* Get the value of RSYSPCFG1 to check the current error pin monitoring setting */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Rsyspcfg1RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->SYSPCFG1.U = spiFrame.B.data;

    if(tlfDevice->SYSPCFG1.B.ERREN == ErrPinMonitor_enabled)
    {
        tlfDevice->SYSPCFG1.B.ERREN = ErrPinMonitor_disabled;
        transferDataTLF35584(SpiCommand_write, Syspcfg1RegAddr, tlfDevice->SYSPCFG1.U);
    }
}

void enableErrPinMonitorTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    /* Get the value of RSYSPCFG1 to check the current error pin monitoring setting */
    spiFrame.U = transferDataTLF35584(SpiCommand_read, Rsyspcfg1RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->SYSPCFG1.U = spiFrame.B.data;

    if(tlfDevice->SYSPCFG1.B.ERREN == ErrPinMonitor_disabled)
    {
        tlfDevice->SYSPCFG1.B.ERREN = ErrPinMonitor_enabled;
        transferDataTLF35584(SpiCommand_write, Syspcfg1RegAddr, tlfDevice->SYSPCFG1.U);
    }
}

void enableVoltageSupplyRails(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, DevctrlRegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->DEVCTRL.U = spiFrame.B.data;

    /* Enable all voltage supply rails */
    tlfDevice->DEVCTRL.B.COMEN = CommunicationLdoVoltage_enabled;
    tlfDevice->DEVCTRL.B.VREFEN = VoltageReferenceQVR_enabled;

    /* Update device register values */
    transferDataTLF35584(SpiCommand_write, DevctrlRegAddr, tlfDevice->DEVCTRL.U);
    transferDataTLF35584(SpiCommand_write, DevctrlnRegAddr, ~tlfDevice->DEVCTRL.U);
}

void setStateTransitionTLF35584(tlf35584 *tlfDevice, statereqType requestedStateTransition)
{
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, DevctrlRegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->DEVCTRL.U = spiFrame.B.data;
    /* Set the requested state transition of TLF device locally */
    tlfDevice->DEVCTRL.B.STATEREQ = requestedStateTransition;
    switch(requestedStateTransition){
        case DeviceStateTransition_normal:
            tlfDevice->DEVCTRL.B.COMEN = CommunicationLdoVoltage_enabled;
            tlfDevice->DEVCTRL.B.VREFEN = ReferenceVoltage_enabled;
            tlfDevice->DEVCTRL.B.TRK1EN = Tracker1Voltage_enabled;
            tlfDevice->DEVCTRL.B.TRK2EN = Tracker2Voltage_enabled;
            break;
        default:
            break;
    }

    /* Update device register values */
    transferDataTLF35584(SpiCommand_write, DevctrlRegAddr, tlfDevice->DEVCTRL.U);
    transferDataTLF35584(SpiCommand_write, DevctrlnRegAddr, ~tlfDevice->DEVCTRL.U);

    spiFrame.U = transferDataTLF35584(SpiCommand_read, DevctrlRegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->DEVCTRL.U = spiFrame.B.data;
}

stateStatusType getCurrentStateTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, DevstatRegAddr, (uint8)DUMMY_DATA);
    tlfDevice->DEVSTAT.U = spiFrame.B.data;

    return tlfDevice->DEVSTAT.B.STATE;
}

uint8 getInterruptFlagsTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, IFRegAddr, (uint8)DUMMY_DATA);

    tlfDevice->IF.U = spiFrame.B.data;

    return tlfDevice->IF.U;
}

void clearInterruptFlagsTLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->SYSSF.U = CLEAR_STATUS_FLAGS;
    transferDataTLF35584(SpiCommand_write, IFRegAddr, tlfDevice->IF.U);
}

uint8 getSystemStatusFlagsTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, SyssfRegAddr, (uint8)DUMMY_DATA);

    tlfDevice->SYSSF.U = spiFrame.B.data;

    return tlfDevice->SYSSF.U;
}

void clearSystemStatusFlagsTLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->SYSSF.U = CLEAR_STATUS_FLAGS;
    transferDataTLF35584(SpiCommand_write, SyssfRegAddr, tlfDevice->SYSSF.U);
}

uint8 getSpiStatusFlagsTLF35584(tlf35584 *tlfDevice)
{
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, SpisfRegAddr, (uint8)DUMMY_DATA);

    tlfDevice->SPISF.U = spiFrame.B.data;

    return tlfDevice->SPISF.U;
}

void clearSpiStatusFlagsTLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->SPISF.U = CLEAR_STATUS_FLAGS;
    transferDataTLF35584(SpiCommand_write, SpisfRegAddr, tlfDevice->SPISF.U);
}

uint8 getMonitorStatusFlags0TLF35584(tlf35584 *tlfDevice)
{ 
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, Monsf0RegAddr, (uint8)DUMMY_DATA);

    tlfDevice->MONSF0.U = spiFrame.B.data;

    return tlfDevice->MONSF0.U;
}

void clearMonitorStatusFlags0TLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->MONSF0.U = 0xFF;
    transferDataTLF35584(SpiCommand_write, Monsf0RegAddr, tlfDevice->MONSF0.U);
}

uint8 getMonitorStatusFlags1TLF35584(tlf35584 *tlfDevice)
{ 
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, Monsf1RegAddr, (uint8)DUMMY_DATA);

    tlfDevice->MONSF1.U = spiFrame.B.data;

    return tlfDevice->MONSF1.U;
}

void clearMonitorStatusFlags1TLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->MONSF1.U = 0xFF;
    transferDataTLF35584(SpiCommand_write, Monsf1RegAddr, tlfDevice->MONSF1.U);
}

uint8 getMonitorStatusFlags2TLF35584(tlf35584 *tlfDevice)
{ 
    tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, Monsf2RegAddr, (uint8)DUMMY_DATA);

    tlfDevice->MONSF2.U = spiFrame.B.data;

    return tlfDevice->MONSF2.U;
}

void clearMonitorStatusFlags2TLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->MONSF2.U = 0xFF;
    transferDataTLF35584(SpiCommand_write, Monsf2RegAddr, tlfDevice->MONSF2.U);
}

uint8 setAbistSelect0TLF35584(tlf35584 *tlfDevice)
{ 
    tlf35584SpiFrameType spiFrame;
    uint8 transData = 0xD0;

    transferDataTLF35584(SpiCommand_write, AbistSelect0RegAddr, transData);

    spiFrame.U = transferDataTLF35584(SpiCommand_read, AbistSelect0RegAddr, (uint8)DUMMY_DATA);
    tlfDevice->ABISTSELECT0.U = spiFrame.B.data;

    return tlfDevice->ABISTSELECT0.U;
}
void clearAbistSelect0TLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->ABISTSELECT0.U = 0x00;
    transferDataTLF35584(SpiCommand_write, AbistSelect0RegAddr, tlfDevice->ABISTCTRL0.U);
}
uint8 setAbistSelect1TLF35584(tlf35584 *tlfDevice)
{ 
    tlf35584SpiFrameType spiFrame;
    uint8 transData=0xF1;

    transferDataTLF35584(SpiCommand_write, AbistSelect1RegAddr, transData);

    spiFrame.U = transferDataTLF35584(SpiCommand_read, AbistSelect1RegAddr, (uint8)DUMMY_DATA);
    tlfDevice->ABISTSELECT1.U = spiFrame.B.data;

    return tlfDevice->ABISTSELECT1.U;
}
void clearAbistSelect1TLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->ABISTCTRL0.U = 0x00;
    transferDataTLF35584(SpiCommand_write, AbistSelect1RegAddr, tlfDevice->ABISTCTRL0.U);
}

uint8 setAbistCtrl0TLF35584(tlf35584 *tlfDevice)
{ 
    tlf35584SpiFrameType spiFrame;

    uint8 transData = 0x0B;

    transferDataTLF35584(SpiCommand_write, AbistCtrl0RegAddr, transData);

    spiFrame.U = transferDataTLF35584(SpiCommand_read, AbistCtrl0RegAddr, (uint8)DUMMY_DATA);
    tlfDevice->ABISTCTRL0.U = spiFrame.B.data;

    return tlfDevice->ABISTCTRL0.U;
}

void clearAbistCtrl0TLF35584(tlf35584 *tlfDevice)
{
    tlfDevice->ABISTCTRL0.U = 0x00;
    transferDataTLF35584(SpiCommand_write, AbistCtrl0RegAddr, tlfDevice->ABISTCTRL0.U);
}

uint8 UpdatePowerFlagsTLF35584(tlf35584 *tlfDevice){
    getMonitorStatusFlags0TLF35584(tlfDevice);
    getMonitorStatusFlags1TLF35584(tlfDevice);
    getMonitorStatusFlags2TLF35584(tlfDevice);
}
void clearPowerFlagsTLF35584(tlf35584 *tlfDevice){
    clearMonitorStatusFlags0TLF35584(tlfDevice);
    clearMonitorStatusFlags1TLF35584(tlfDevice);
    clearMonitorStatusFlags2TLF35584(tlfDevice);
}
uint8 AbistTestTLF35584(tlf35584 *tlfDevice){
    setAbistSelect0TLF35584(tlfDevice);
    setAbistSelect1TLF35584(tlfDevice);
    setAbistCtrl0TLF35584(tlfDevice);
};

void clearAbistFlagsTLF35584(tlf35584 *tlfDevice){
    clearAbistSelect0TLF35584(tlfDevice);
    clearAbistSelect1TLF35584(tlfDevice);
    clearAbistCtrl0TLF35584(tlfDevice);
};
/* This function initializes the TLF35584 device */
void initTLF35584(tlf35584 *tlfDevice)
{
    unlockRegisterTLF35584();
    disableWindowWatchdogTLF35584(tlfDevice);
    disableErrPinMonitorTLF35584(tlfDevice);
    lockRegisterTLF35584();

    /* Enable voltage supply rails to prevent External Voltage Regulator (EVR) under-voltage alarm activation */
    enableVoltageSupplyRails(tlfDevice);
}

uint16 transferDataTLF35584(spiCommandType cmd, tlf35584RegAddr addr, uint8 data)
{
    tlf35584SpiFrameType spiFrame = {0};
    uint16 SpiMasterRxBuffer[1];

    /* Prepare the SPI frame that should be transfered to the TLF35584 device */
    spiFrame.B.cmd = cmd;
    spiFrame.B.addr = addr;
    //check4 = spiFrame.B.addr;
    spiFrame.B.data = data;

    /* Store the prepared SPI frame to Master Tx Buffer And Transfer the Data Type */
    uint16 SpiMasterTxButter[1] = {0};
    SpiMasterTxButter[0] = spiFrame.U;
    //if (cmd == 0) SpiMasterTxButter[0] = 0xAA55;
    //SpiMasterTxButter[0] = (uint8)(spiFrame.U & 0xFF00) >> 8;
    //SpiMasterTxButter[1] = (uint8)(spiFrame.U & 0xFF);

    /* Wait until the previous communication has finished, if any */

    /* Send a data stream through the SPI Master */
    Spi4Send(&SpiMasterTxButter[0], &SpiMasterRxBuffer[0], PMIC_SPI_BUFFER_SIZE);

    /* Wait until the values are read from the TLF device */

    return SpiMasterRxBuffer[0];
}
